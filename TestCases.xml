<?xml version="1.0" encoding="utf-8"?>
<WopiValidation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="TestCases.xsd">
  <Resources>
    <!-- Contains files that can be used by test cases -->
    <File Id="WordBlankDocument" Name="WordBlankDocument.docx" FilePath="Resources\WordBlankDocument.docx" />
    <File Id="WordSimpleDocument" Name="WordSimpleDocument.docx" FilePath="Resources\WordSimpleDocument.docx" />
    <File Id="WordComplexDocument" Name="WordComplexDocument.docx" FilePath="Resources\WordComplexDocument.docx" />
    <File Id="WordZeroByteDocument" Name="WordZeroBytesDocument.docx" FilePath="Resources\WordZeroBytesDocument.docx" />
    <File Id="ExcelBlankWorkbook" Name="ExcelBlankWorkbook.xlsx" FilePath="Resources\ExcelBlankWorkbook.xlsx" />
    <File Id="ZeroByteFile" Name="ZeroByteFile.wopitest" FilePath="Resources\ZeroByteFile.wopitest" />
    <!--Empty byte file for Zip Chunking-->
    <File Id="ZeroByteOfficeDocument" Name="" FilePath="" />
    <!--Non zero byte Excel files for Zip Chunking-->
    <File Id="NonZeroByteExcel_Main_V1" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version1.MainContent." />
    <File Id="NonZeroByteExcel_Alt_V1" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version1.AltContent." />
    <File Id="NonZeroByteExcel_Main_V2" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version2.MainContent." />
    <File Id="NonZeroByteExcel_Alt_V2" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version2.AltContent." />
    <File Id="NonZeroByteExcel_Main_V3" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version3.MainContent." />
    <File Id="NonZeroByteExcel_Alt_V3" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteExcel.Version3.AltContent." />
    <!--Non zero byte Ppt files for Zip Chunking-->
    <File Id="NonZeroBytePpt_Main_V1" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroBytePpt.Version1.MainContent." />
    <File Id="NonZeroBytePpt_Main_V2" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroBytePpt.Version2.MainContent." />
    <File Id="NonZeroBytePpt_Main_V3" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroBytePpt.Version3.MainContent." />
    <!--Non zero byte Word files for Zip Chunking-->
    <File Id="NonZeroByteWord_Main_V1" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteWord.Version1.MainContent." />
    <File Id="NonZeroByteWord_Main_V2" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteWord.Version2.MainContent." />
    <File Id="NonZeroByteWord_Main_V3" Name="ChunkIds.txt" FilePath="Microsoft.Office.WopiValidator.Core.Resources.ZipChunking.NonZeroByteWord.Version3.MainContent." />
  </Resources>
  <PrereqCases>
    <TestCase Name="WopiValidatorPrereq" Category="WopiCore">
      <Description>
        The prereq WOPI validation that must pass prior to running the (potentially destructive) test suite.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <StringProperty Name="BaseFileName" EndsWith=".wopitest" IsRequired="true" IgnoreCase="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="UserCanWritePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the user has permission to perform Write operation.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="UserCanWrite" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="UserCanNotWriteRelativePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the user is denied permission to call PutRelativeFile.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="UserCanNotWriteRelative" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="UserCanWriteRelativePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the user has permission to call PutRelativeFile.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="UserCanNotWriteRelative" ExpectedValue="false" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ContainersPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for Containers operations.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsContainers" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ContainersUnsupportedPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check that the host does NOT support Containers operations.
        This can be used in cases where a test group should be skipped if the host DOES support Containers
        operations.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsContainers" ExpectedValue="false" IsRequired="false" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="EcosystemPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for Ecosystem operations.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsEcosystem" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="LocksPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for Lock/Unlock/RefreshLock/UnlockAndRefreshLock
        operations.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsLocks" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="FileEditingPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if host declares support for PutFile/PutRelativeFile operations.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsUpdate" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="GetLockPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if host declares support for GetLock operation.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsGetLock" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ExtendedLockLengthPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if host declares support for extended lock lengths.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsExtendedLockLength" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="BusinessFlowPrereq" Category="WopiCore">
      <Description>
        The prereq BusinessFlowPrereq must pass prior to running the feature validations related to business flows.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="LicenseCheckForEditIsEnabled" IsRequired="true" ExpectedValue="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="DeleteFilePrereq" Category="WopiCore">
      <Description>
        The host must support /files/DeleteFile.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsDeleteFile" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="FileUrlUsagePrereq" Category="WopiCore">
      <Description>
        The host uses FileUrl for direct file access.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <AbsoluteUrlProperty Name="FileUrl" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="SupportedShareUrlTypesForFilePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host sets SupportedShareUrlTypes in CheckFileInfo to any value.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ShareUrlTypeReadOnlyForFilePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for the "ReadOnly" Share Url type for the file.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" ContainsValue="ReadOnly" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ShareUrlTypeReadWriteForFilePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for the "ReadWrite" Share Url type for the file.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" ContainsValue="ReadWrite" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="SupportedShareUrlTypesForContainerPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host sets SupportedShareUrlTypes in CheckContainerInfo to any value.
      </Description>
      <Requests>
        <EnumerateAncestors>
          <SaveState>
            <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
            <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
          </SaveState>
        </EnumerateAncestors>
        <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckContainerInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ShareUrlTypeReadOnlyForContainerPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for the "ReadOnly" Share Url type for the container.
      </Description>
      <Requests>
        <EnumerateAncestors>
          <SaveState>
            <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
            <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
          </SaveState>
        </EnumerateAncestors>
        <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" ContainsValue="ReadOnly" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckContainerInfo>
      </Requests>
    </TestCase>

    <TestCase Name="ShareUrlTypeReadWriteForContainerPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the host declares support for the "ReadWrite" Share Url type for the container.
      </Description>
      <Requests>
        <EnumerateAncestors>
          <SaveState>
            <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
            <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
          </SaveState>
        </EnumerateAncestors>
        <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
          <Validators>
            <JsonResponseContentValidator>
              <ArrayProperty Name="SupportedShareUrlTypes" ContainsValue="ReadWrite" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckContainerInfo>
      </Requests>
    </TestCase>

    <TestCase Name="RenameFilePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if host declares support for RenameFile operation.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="UserCanCreateChildFilePrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the user has permission to call CreateChildFile operation.
      </Description>
      <Requests>
        <EnumerateAncestors>
          <SaveState>
            <!-- Get the Url property of the last child of AncestorsWithRootFirst -->
            <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
          </SaveState>
        </EnumerateAncestors>
        <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckContainerInfo>
      </Requests>
    </TestCase>

    <TestCase Name="AddActivitiesPrereq" Category="WopiCore">
      <Description>
        The host must support /files/AddActivities.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsAddActivities" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="UserCanRenameContainerPrereq" Category="WopiCore">
      <Description>
        Prereq WOPI Validation test to check if the user has permissions to call RenameContainer.
      </Description>
      <Requests>
        <EnumerateAncestors>
          <SaveState>
            <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
          </SaveState>
        </EnumerateAncestors>
        <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckContainerInfo>
      </Requests>
    </TestCase>

    <TestCase Name="SupportsUserInfoPrereq" Category="WopiCore">
      <Description>
        The host must support /files/PutUserInfo.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsUserInfo" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="SupportsCoauthPrereq" Category="WopiCoauth">
      <Description>
        The host must support coauth.
      </Description>
      <Requests>
        <CheckFileInfo>
          <Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsCoauth" ExpectedValue="true" IsRequired="true" />
              <LongProperty Name="AccessTokenExpiry" IsRequired="true" />
              <AbsoluteUrlProperty Name="RealTimeChannelEndpointUrl" IsRequired="true" />
              <AbsoluteUrlProperty Name="OfficeCollaborationServiceEndpointUrl" IsRequired="true" />
              <IntegerProperty Name="SequenceNumber" IsRequired="true" />
              <LongProperty Name="ServerTime" IsRequired="true" />
              <BooleanProperty Name="SupportsLocks" ExpectedValue="true" IsRequired="true" />
              <BooleanProperty Name="SupportsUpdate" ExpectedValue="true" IsRequired="true" />
              <BooleanProperty Name="SupportsUserInfo" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
            <Or>
              <JsonResponseContentValidator>
                <StringProperty Name="SharingStatus" ExpectedValue="Private" IsRequired="true" />
              </JsonResponseContentValidator>
              <JsonResponseContentValidator>
                <StringProperty Name="SharingStatus" ExpectedValue="Shared" IsRequired="true" />
              </JsonResponseContentValidator>
            </Or>
          </Validators>
        </CheckFileInfo>
      </Requests>
    </TestCase>

    <TestCase Name="SupportsChunkedFileTransferPrereq" Category="WopiCoauth">
      <Description>
        The host must support Incremental File Transfer protocol.
      </Description>
      <Requests>
        <CheckFileInfo>
          <!--TODO: Uncomment the validators once all APIs are implemented-->
          <!--<Validators>
            <JsonResponseContentValidator>
              <BooleanProperty Name="SupportsChunkedFileTransfer" ExpectedValue="true" IsRequired="true" />
            </JsonResponseContentValidator>
          </Validators>-->
        </CheckFileInfo>
      </Requests>
    </TestCase>
  </PrereqCases>

  <TestGroup Name="CheckFileInfoSchema">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="FullCheckFileInfoSchema" Category="WopiCore">
        <Description>
          This tests that hosts' CheckFileInfo responses conform to the JSON schema.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonSchemaValidator Schema="CheckFileInfoSchema" />
              <JsonResponseContentValidator>
                <!-- BaseFileName should *not* start with a "."; it should be a full file name. -->
                <StringRegexProperty Name="BaseFileName" ExpectedValue="^\..*$" IsRequired="false" ShouldMatch="false" />

                <!-- FileExtension, if provided, should start with a "."; using this as a shortcut to test for that. -->
                <StringProperty Name="FileExtension" ExpectedValue=".wopitest" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>
      <TestCase Name="HostUrls" Category="OfficeOnline">
        <Description>
          This tests that the Host* URLs provided by the host are not Office Online action URLs.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringRegexProperty Name="CloseUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="DownloadUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="FileSharingUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="FileUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="FileVersionUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="HostEditUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="HostEmbeddedViewUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="HostViewUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="SignInUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="SignoutUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
                <StringRegexProperty Name="WorkflowUrl" ExpectedValue="^https:\/\/.*?\.officeapps(-df)?\.live\.com.+" IsRequired="false" ShouldMatch="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <!-- Access token related testcases -->
      <TestCase Name="CheckFileWithInvalidAccessToken" Category="WopiCore">
        <Description>
          Simulates a CheckFileInfo request with invalid access token and expects a 401 or 404 response.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="BaseWopiViewing">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
    </PrereqTests>
    <!-- Full Viewer app sequences -->
    <TestCases>
      <TestCase Name="ViewOnlySupport" Category="WopiCore">
        <Description>
          Standard sequence of requests made by a WOPI client to render a document.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="BaseFileName" IsRequired="true" />
                <StringProperty Name="OwnerId" IsRequired="true" />
                <LongProperty Name="Size" IsRequired="true" />
                <StringProperty Name="Version" IsRequired="true" />

                <AbsoluteUrlProperty Name="BreadcrumbBrandUrl" />
                <AbsoluteUrlProperty Name="BreadcrumbDocUrl" />
                <AbsoluteUrlProperty Name="BreadcrumbFolderUrl" />
                <AbsoluteUrlProperty Name="DownloadUrl" />
                <AbsoluteUrlProperty Name="CloseUrl" />
                <AbsoluteUrlProperty Name="HostEditUrl" />
                <AbsoluteUrlProperty Name="HostViewUrl" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <GetFile />
        </Requests>
      </TestCase>

      <TestCase Name="GetUnlockedFile" Category="WopiCore">
        <Description>
          GetFile requests on a file that wasn't locked before - necessary for Viewing and Editing.
        </Description>
        <Requests>
          <GetFile />
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="Locks">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- Lock length validation -->
      <TestCase Name="LockLengthValidation" Category="WopiCore">
        <Description>
          Tests that the WOPI host is capable of handling WOPI Lock IDs of 256 characters.
        </Description>
        <Requests>
          <Lock Lock="1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456" />
          <Unlock Lock="1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456" />
        </Requests>
      </TestCase>

      <!-- Lock format validation -->
      <TestCase Name="LockFormatValidation" Category="WopiCore">
        <Description>
          Tests that Office locks, which happen to be JSON-formatted strings today, are handled properly by the host.
        </Description>
        <Requests>
          <Lock Lock="{&quot;S&quot;:&quot;0136ad16-9725-43c3-9ea0-5e01d2dbc162&quot;,&quot;E&quot;:2,&quot;M&quot;:&quot;DE997C5AC4E6&quot;,&quot;P&quot;:&quot;6058AF1E-A36F-4691-9003-B8E2C7F50937&quot;}" />
          <Unlock Lock="{&quot;S&quot;:&quot;0136ad16-9725-43c3-9ea0-5e01d2dbc162&quot;,&quot;E&quot;:2,&quot;M&quot;:&quot;DE997C5AC4E6&quot;,&quot;P&quot;:&quot;6058AF1E-A36F-4691-9003-B8E2C7F50937&quot;}" />
        </Requests>
      </TestCase>

      <!-- Lock requests -->
      <TestCase Name="SuccessfulLockSequence" Category="WopiCore">
        <Description>
          Simulates a successful sequence of lock-related requests: Lock, RefreshLock, UnlockAndRelock, Unlock.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <RefreshLock Lock="LockString" />
          <UnlockAndRelock NewLock="NewLockString" OldLock="LockString" />
          <Unlock Lock="NewLockString" />
        </Requests>
      </TestCase>

      <TestCase Name="LockMismatchAfterUnlockAndRelockRequest" Category="WopiCore">
        <Description>
          Simulates a successful UnlockAndRelock followed by Unlock with old lock. This tests that UnlockAndRelock actually changes the lock string
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <UnlockAndRelock OldLock="LockString" NewLock="NewLockString" />
          <Unlock Lock="LockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="NewLockString" />
            </Validators>
          </Unlock>
          <Unlock Lock="NewLockString" />
        </Requests>
      </TestCase>

      <TestCase Name="DoubleLockSequence" Category="WopiCore">
        <Description>
          Two Lock calls in a row with the same Lock ID should work.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Lock Lock="LockString" />
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <TestCase Name="UnlockUnlockedFile" Category="WopiCore">
        <Description>
          Responses to Unlock requests on an unlocked file should include the X-WOPI-Lock header set to the empty string.
        </Description>
        <Requests>
          <Unlock Lock="LockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="" />
            </Validators>
          </Unlock>
        </Requests>
      </TestCase>

      <!-- LockMismatch -->
      <TestCase Name="LockMismatchOnLockRequest" Category="WopiCore">
        <Description>
          Simulates a lock mismatch when trying to refresh the lock.
          Validates that the current lock ID is returned as response header.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Lock Lock="IncorrectLockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="LockString" />
            </Validators>
          </Lock>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <TestCase Name="LockMismatchOnUnlockRequest" Category="WopiCore">
        <Description>
          Simulates a lock mismatch when trying to unlock the file.
          Validates that the current lock ID is returned as response header.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Unlock Lock="IncorrectLockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="LockString" />
            </Validators>
          </Unlock>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <TestCase Name="LockMismatchOnRefreshLockRequest" Category="WopiCore">
        <Description>
          Simulates a lock mismatch when trying to refresh the lock.
          Validates that the current lock ID is returned as response header.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <RefreshLock Lock="IncorrectLockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="LockString" />
            </Validators>
          </RefreshLock>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <TestCase Name="LockMismatchOnUnlockAndRelockRequest" Category="WopiCore">
        <Description>
          Simulates a lock mismatch when trying to unlock and relock the file.
          Validates that the current lock ID is returned as response header.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <UnlockAndRelock OldLock="IncorrectLockString" NewLock="NewLockString">
            <Validators>
              <LockMismatchValidator ExpectedLock="LockString" />
            </Validators>
          </UnlockAndRelock>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <TestCase Name="LockMismatchOnPutFileRequest" Category="WopiCore">
        <Description>
          Simulates a lock mismatch when trying to refresh the lock.
          Validates that the current lock ID is returned as response header.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="IncorrectLockString" ResourceId="WordBlankDocument">
            <Validators>
              <LockMismatchValidator ExpectedLock="LockString" />
            </Validators>
          </PutFile>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>

      <!-- Invalid access token on Lock requests -->
      <TestCase Name="LockFileWithInvalidAccessToken" Category="WopiCore">
        <Description>
          Tests Lock operation with an invalid access token and expects a 401 or 404 response.
        </Description>
        <Requests>
          <Lock Lock="LockString">
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </Lock>
        </Requests>
      </TestCase>

      <!-- Invalid access token on Unlock requests -->
      <TestCase Name="UnlockFileWithInvalidAccessToken" Category="WopiCore">
        <Description>
          Tests Unlock operation with an invalid access token and expects a 401 or 404 response.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Unlock Lock="LockString">
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </Unlock>
          <Unlock Lock="LockString" />
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains GetLock test cases -->
  <TestGroup Name="GetLock">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>GetLockPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /files/GetLock -->
      <TestCase Name="files.GetLock" Category="WopiCore">
        <Description>
          Tests the standard GetLock flow; Lock, GetLock, then Unlock.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <GetLock>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-Lock" ExpectedValue="LockString" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </GetLock>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="files.GetLockAfterChange" Category="WopiCore">
        <Description>
          Tests that the lock ID GetLock returns changes after it's changed by UnlockAndRelock.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <UnlockAndRelock NewLock="NewLockString" OldLock="LockString" />
          <GetLock>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-Lock" ExpectedValue="NewLockString" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </GetLock>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="NewLockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="files.GetLockOnUnlockedFile" Category="WopiCore">
        <Description>
          Tests GetLock after a file has been locked and unlocked.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Unlock Lock="LockString" />
          <GetLock>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-Lock" ExpectedValue="" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </GetLock>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="ExtendedLockLength">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>GetLockPrereq</PrereqTest>
      <PrereqTest>ExtendedLockLengthPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /files/Lock: test new 1024 character lock length -->
      <TestCase Name="files.ExtendedLockLengthValidation" Category="WopiCore">
        <Description>
          Tests that the WOPI host is capable of handling WOPI Lock IDs of 1024 characters.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsExtendedLockLength" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock Lock="1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345612345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234561234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456" />
          <GetLock />
          <Unlock Lock="1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345612345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234561234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456" />
        </Requests>
        <CleanupRequests>
          <Unlock Lock="1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345612345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234561234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="EditFlows">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>UserCanWritePrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="BasicEdit" Category="WopiCore">
        <Description>
          Standard sequence of requests made by an edit-capable WOPI client as part of application boot and successful saves when user interacts with the document.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="BaseFileName" IsRequired="true" />
                <StringProperty Name="OwnerId" IsRequired="true" />
                <LongProperty Name="Size" IsRequired="true" />
                <StringProperty Name="Version" IsRequired="true" />

                <AbsoluteUrlProperty Name="BreadcrumbBrandUrl" />
                <AbsoluteUrlProperty Name="BreadcrumbDocUrl" />
                <AbsoluteUrlProperty Name="BreadcrumbFolderUrl" />
                <AbsoluteUrlProperty Name="DownloadUrl" />
                <AbsoluteUrlProperty Name="CloseUrl" />
                <AbsoluteUrlProperty Name="HostEditUrl" />
                <AbsoluteUrlProperty Name="HostViewUrl" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock Lock="LockString" />
          <GetFile Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetFile>
            <Validators>
              <ResponseContentValidator ExpectedResourceId="WordSimpleDocument" />
            </Validators>
          </GetFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="EditNoChange" Category="WopiCore">
        <Description>
          Simulates an editor boot and save with no changes to a file.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="BaseFileName" IsRequired="true" />
                <StringProperty Name="OwnerId" IsRequired="true" />
                <LongProperty Name="Size" IsRequired="true" />
                <StringProperty Name="Version" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock Lock="LockString" />
          <GetFile Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <!-- Requests to unlocked file -->
      <TestCase Name="PutUnlockedFile" Category="WopiCore">
        <Description>
          Simulates creating a new file on the host, which requires PutFile requests to an unlocked 0-byte file to succeed.
        </Description>
        <Requests>
          <!-- Set up the test -->
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="ZeroByteFile" />
          <Unlock Lock="LockString" />

          <!-- Execute the actual test -->
          <PutFile ResourceId="WordBlankDocument" />
          <GetFile>
            <Validators>
              <ResponseContentValidator ExpectedResourceId="WordBlankDocument" />
            </Validators>
          </GetFile>
        </Requests>
        <CleanupRequests>
          <!-- If any of the setup steps fail, subsequent requests won't be issued, leaving the file potentially locked, so unlock it here in a cleanup request. -->
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutUnlockedFileNotZeroBytes" Category="WopiCore">
        <Description>
          This tests that PutFile requests fail when executed against files that are not zero bytes.
        </Description>
        <Requests>
          <!-- Set up the test -->
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />

          <!-- Execute the actual test -->
          <PutFile ResourceId="WordBlankDocument">
            <Validators>
              <!-- Should return a 409 since the file is unlocked and not zero bytes -->
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="GetPutFileWithInvalidAccessToken" Category="WopiCore">
        <Description>
          Simulates Get and PutFile requests with invalid access token and expects a 401 or 404 response.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <GetFile Lock="LockString">
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </GetFile>
          <GetFile Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument">
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </PutFile>
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains FileVersion test cases to verify X-WOPI-ItemVersion value -->
  <TestGroup Name="FileVersion">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>

      <!-- /files/GetFile returns X-WOPI-ItemVersion -->
      <TestCase Name="files.GetFileReturnsVersion" Category="WopiCore">
        <Description>
          /files/GetFile should return the current version of the file
        </Description>
        <Requests>
          <GetFile>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" />
            </Validators>
          </GetFile>
        </Requests>
      </TestCase>

      <!-- /files/Lock and /files/Unlock return X-WOPI-ItemVersion -->
      <TestCase Name="files.LockReturnsVersion" Category="WopiCore">
        <Description>
          /files/Lock should return the current version of the file
        </Description>
        <Requests>
          <Lock Lock="LockString">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" />
            </Validators>
          </Lock>
          <Unlock Lock="LockString" />
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="files.UnlockReturnsVersion" Category="WopiCore">
        <Description>
          /files/Unlock should return the current version of the file
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <Unlock Lock="LockString">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" />
            </Validators>
          </Unlock>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <!-- /files/PutFile returns X-WOPI-ItemVersion -->
      <TestCase Name="files.PutFileReturnsVersion" Category="WopiCore">
        <Description>
          /files/PutFile should return the current version of the file
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" />
            </Validators>
          </PutFile>
          <Unlock Lock="LockString" />
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <!-- /files/PutFile returns a different X-WOPI-ItemVersion -->
      <TestCase Name="files.PutFileReturnsDifferentVersion" Category="WopiCore">
        <Description>
          Performs consecutive PutFile operations to verify that the X-WOPI-ItemVersion header value is changed with every PutFile operation.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <CheckFileInfo>
            <SaveState>
              <State Name="OriginalVersion" Source="Version" />
            </SaveState>
          </CheckFileInfo>
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="SecondVersion" Source="X-WOPI-ItemVersion" SourceType="Header" />
            </SaveState>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" ExpectedStateKey="OriginalVersion" ShouldMatch="false" />
            </Validators>
          </PutFile>
          <PutFile Lock="LockString" ResourceId="WordComplexDocument">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" ExpectedStateKey="SecondVersion" ShouldMatch="false" />
            </Validators>
          </PutFile>
          <Unlock Lock="LockString">
            <SaveState>
              <State Name="VersionOnUnlock" Source="X-WOPI-ItemVersion" SourceType="Header" />
            </SaveState>
          </Unlock>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Version" ExpectedStateKey="VersionOnUnlock" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>

      <!-- /files/GetFile, /files/Lock and /files/Unlock returns the same X-WOPI-ItemVersion -->
      <TestCase Name="files.LockAndUnlockAfterGetFileReturnsSameVersion" Category="WopiCore">
        <Description>
          Performs Lock and Unlock operations after a GetFile operation to verify that the X-WOPI-ItemVersion header value is unchanged.
        </Description>
        <Requests>
          <CheckFileInfo>
            <SaveState>
              <State Name="OriginalVersion" Source="Version" />
            </SaveState>
          </CheckFileInfo>
          <GetFile>
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" ExpectedStateKey="OriginalVersion" />
            </Validators>
          </GetFile>
          <Lock Lock="LockString">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" ExpectedStateKey="OriginalVersion" />
            </Validators>
          </Lock>
          <Unlock Lock="LockString">
            <Validators>
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" ExpectedStateKey="OriginalVersion" />
            </Validators>
          </Unlock>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains PutUserInfo test cases -->
  <TestGroup Name="PutUserInfo">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsUserInfoPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>

      <!-- PutUserInfo call returns 200 and subsequent CheckFileInfo calls return the correct value -->
      <TestCase Name="PutUserInfoSucceeds" Category="WopiCore">
        <Description>
          PutUserInfo call returns 200 and subsequent CheckFileInfo calls return the correct value
        </Description>
        <Requests>
          <PutUserInfo>
            <RequestBody>PutUserInfoTest</RequestBody>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </PutUserInfo>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="UserInfo" ExpectedValue="PutUserInfoTest" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify PutRelativeFile operation -->
  <TestGroup Name="PutRelativeFile">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>UserCanWriteRelativePrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>DeleteFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="PutRelativeFile.SuggestedExtension" Category="WopiCore">
        <Description>
          Tests the basic PutRelativeFile scenario where a suggested extension is specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Suggested" Name=".wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith=".wopitestx" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.SuggestedName" Category="WopiCore">
        <Description>
          Tests the basic PutRelativeFile scenario where a suggested name is specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Suggested" Name="madeupname.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.SuggestedNameConflict" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a suggested name is specified but
          a file with the target name already exists. Expects the request to succeed with the host
          choosing a suitable name.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Suggested" Name="madeupname.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl1" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <PutRelativeFile PutRelativeFileMode="Suggested" Name="madeupname.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl2" Source="Url" />
            </SaveState>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl1" />
          <DeleteFile OverrideUrl="$State:NewUrl2" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeName" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified. Expects the created file to have
          the exact name specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameOverwriteTrueNoEffect" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative
          is set to true. Since no file with target name exists in this scenario, the header should have
          no effect.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument" OverwriteRelative="true">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameOverwriteFalseNoEffect" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative
          is set to false. Since no file with target name exists in this scenario, the header should have
          no effect.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument" OverwriteRelative="false">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameConflictNoOverwrite" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative
          is not specified. Since a file with target name exists in this scenario, this should return a 409.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameConflictOverwriteFalse" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative
          is set to false. Since a file with target name exists in this scenario, this should return a 409.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument" OverwriteRelative="false">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameConflictOverwriteTrue" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative is set to true.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl1" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument" OverwriteRelative="true">
            <SaveState>
              <State Name="NewUrl2" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith=".wopitestx" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewUrl2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </CheckFileInfo>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl1" />
          <DeleteFile OverrideUrl="$State:NewUrl2" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.ConflictingHeaders" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where both a suggested name and a relative name are specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Conflicting" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="400" />
                <ResponseCodeValidator ExpectedCode="501" />
              </Or>
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFile.RelativeNameConflictOverwriteTrueLocked" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a relative name is specified along with OverwriteRelative
          set to true, but a file with the same target name already exists and is locked.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <Lock Lock="LockString" OverrideUrl="$State:NewUrl" />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" ResourceId="WordSimpleDocument" OverwriteRelative="true">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" OverrideUrl="$State:NewUrl" />
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.FileNameReturnedIsCorrectlyEncoded" Category="WopiCore">
        <Description>
          Tests that the host returns a UTF-8 encoded version of the FileName after a PutRelativeFile operation.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeup_name.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_name.wopitestx" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.FileNameLongerThan512Chars" Category="WopiCore">
        <Description>
          Tests that the host handles long file names appropriately by either supporting them or returning a 400.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="longwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilename.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="UrlWithFileNameLongerThan512Chars" Source="Url" />
            </SaveState>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="200" />
                <ResponseCodeValidator ExpectedCode="400" />
              </Or>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:UrlWithFileNameLongerThan512Chars" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeFile.IncludeHostUrls" Category="OfficeOnline">
        <Description>
          Tests that the host returns the HostEditUrl and HostViewUrl on their PutRelativeFile response.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="Suggested" Name="new_file.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify correct responses to PutRelativeFile operations when it is unsupported by the host -->
  <TestGroup Name="PutRelativeFileUnsupported">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>UserCanNotWriteRelativePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="PutRelativeFileUnsupported.SuggestedExtension" Category="WopiCore">
        <Description>
          Tests the basic PutRelativeFile scenario where a suggested extension is specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Suggested" Name=".wopitestx" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFileUnsupported.SuggestedName" Category="WopiCore">
        <Description>
          Tests the basic PutRelativeFile scenario where a suggested name is specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Suggested" Name="PutRelativeFileUnsupported_SuggestedName.wopitest" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFileUnsupported.RelativeName" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="PutRelativeFileUnsupported_RelativeName.wopitest" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFileUnsupported.RelativeNameOverwriteTrueNoEffect" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative is set to true.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="PutRelativeFileUnsupported_RelativeNameOverwriteTrueNoEffect.wopitest" ResourceId="WordSimpleDocument" OverwriteRelative="true">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFileUnsupported.RelativeNameOverwriteFalseNoEffect" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where a Relative name is specified and OverwriteRelative is set to false.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="PutRelativeFileUnsupported_RelativeNameOverwriteFalseNoEffect.wopitest" ResourceId="WordSimpleDocument" OverwriteRelative="false">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>

      <TestCase Name="PutRelativeFileUnsupported.ConflictingHeaders" Category="WopiCore">
        <Description>
          Tests the PutRelativeFile scenario where both a suggested name and a relative name are specified.
        </Description>
        <Requests>
          <CheckFileInfo />
          <PutRelativeFile PutRelativeFileMode="Conflicting" Name="PutRelativeFileUnsupported_ConflictingHeaders.wopitest" ResourceId="WordSimpleDocument">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </PutRelativeFile>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify RenameFile and will only be executed if the host does not support the CreateChildFile operation -->
  <TestGroup Name="RenameFileIfCreateChildFileIsNotSupported">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>DeleteFilePrereq</PrereqTest>
      <PrereqTest>ContainersUnsupportedPrereq</PrereqTest>
      <PrereqTest>RenameFilePrereq</PrereqTest>
      <PrereqTest>UserCanWriteRelativePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="PutRelativeAndRenameFile.RenameShouldSucceed" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then rename and delete it. The rename operation should succeed.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeAndRenameFile.FileNameAfterRenameIsCorrectlyEncoded" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then rename it with a file name containing a special character and delete it.
          The rename operation should succeed and the server should return the name as a UTF-8 encoded string.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="madeup_name.wopitestx" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_name.wopitestx" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="madeup_renamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_renamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeAndRenameFile.RenamingALockedFileWithACorrectLockHeaderValueShouldSucceed" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then lock it and try to rename it with the correct lock ID. The rename operation should succeed.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Lock="LockString" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeAndRenameFile.RenamingALockedFileWithAnIncorrectLockHeaderValueShouldReturnA409" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then lock it and try to rename it with an incorrect lock ID.
          The rename operation should fail with a Conflict - 409 status code.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Lock="IncorrectLockString" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeAndRenameFile.RenamingADeletedFileShouldReturnA404" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then delete it and try to rename it. The rename operation should fail with a 404 status code.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="404" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="PutRelativeAndRenameFile.RenameShouldNotChangeFileExtension" Category="WopiCore">
        <Description>
          Perform a PutRelativeFile operation, then rename and delete it. The rename operation should not change the file extension of the file.
        </Description>
        <Requests>
          <PutRelativeFile PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest" ResourceId="WordSimpleDocument">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </PutRelativeFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="BaseFileName" ExpectedValue="ValidatorTestFileRenamed.wopitest" />
                <StringProperty Name="FileExtension" ExpectedValue=".wopitest" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify RenameFile and will only be executed if the host supports the CreateChildFile operation -->
  <TestGroup Name="RenameFileIfCreateChildFileIsSupported">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>DeleteFilePrereq</PrereqTest>
      <PrereqTest>RenameFilePrereq</PrereqTest>
      <PrereqTest>UserCanCreateChildFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="CreateChildFileAndRenameFile.RenameShouldSucceed" Category="WopiCore">
        <Description>
          Create a file, then rename and delete it. The rename operation should succeed.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFileAndRenameFile.FileNameAfterRenameIsCorrectlyEncoded" Category="WopiCore">
        <Description>
          Create a file, then rename it with a file name containing a special character and delete it.
          The rename operation should succeed and the server should return the name as a UTF-8 encoded string.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeup_name.wopitestx">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_name.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="madeup_renamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_renamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFileAndRenameFile.RenamingALockedFileWithACorrectLockHeaderValueShouldSucceed" Category="WopiCore">
        <Description>
          Create a file, then lock it and try to rename it with the correct lock ID. The rename operation should succeed.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Lock="LockString" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFileAndRenameFile.RenamingALockedFileWithAnIncorrectLockHeaderValueShouldReturnA409" Category="WopiCore">
        <Description>
          Create a file, then lock it and try to rename it with an incorrect lock ID.
          The rename operation should fail with a Conflict - 409 status code.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <Lock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Lock="IncorrectLockString" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <Unlock OverrideUrl="$State:NewFileUrl" Lock="LockString" />
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFileAndRenameFile.RenamingADeletedFileShouldReturnA404" Category="WopiCore">
        <Description>
          Create a file, then delete it and try to rename it. The rename operation should fail with a 404 status code.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Get the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="404" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFileAndRenameFile.RenameShouldNotChangeFileExtension" Category="WopiCore">
        <Description>
          Create a file, then rename and delete it. The rename operation should not change the file extension of the file.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="ValidatorTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFile.wopitest" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsRename" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="UserCanRename" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <RenameFile OverrideUrl="$State:NewFileUrl" Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="ValidatorTestFileRenamed" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <CheckFileInfo OverrideUrl="$State:NewFileUrl">
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="BaseFileName" ExpectedValue="ValidatorTestFileRenamed.wopitest" />
                <StringProperty Name="FileExtension" ExpectedValue=".wopitest" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

    </TestCases>
  </TestGroup>

  <!-- Contains Ecosystem test cases -->
  <TestGroup Name="Ecosystem">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>EcosystemPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /files/GetEcosystem -->
      <TestCase Name="files.GetEcosystem" Category="WopiCore">
        <Description>
          Tests that GetEcosystem returns a valid response.
        </Description>
        <Requests>
          <GetEcosystem>
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetEcosystem>
        </Requests>
      </TestCase>

      <!-- /ecosystem/CheckEcosystem -->
      <TestCase Name="ecosystem.CheckEcosystem" Category="WopiCore">
        <Description>
          Tests that CheckEcosystem returns a valid response.
        </Description>
        <Requests>
          <GetEcosystem>
            <SaveState>
              <State Name="EcosystemUrl" Source="Url" />
            </SaveState>
          </GetEcosystem>
          <CheckEcosystem EcosystemUrl="$State:EcosystemUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="SupportsContainers" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckEcosystem>
        </Requests>
      </TestCase>

      <!-- /ecosystem/GetWopiSrc -->
      <!-- No tests -->

      <!-- /ecosystem/GetRootContainer -->
      <TestCase Name="ecosystem.GetRootContainer" Category="WopiCore">
        <Description>
          Tests that GetRootContainer returns a valid response.
        </Description>
        <Requests>
          <GetEcosystem>
            <SaveState>
              <State Name="EcosystemUrl" Source="Url" />
            </SaveState>
          </GetEcosystem>
          <GetRootContainer OverrideUrl="$State:EcosystemUrl" WopiSrc="$State:OriginalWopiEndpoint">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ContainerPointer.Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="ContainerPointer.Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetRootContainer>
        </Requests>
      </TestCase>

      <TestCase Name="ecosystem.GetRootContainerInvalidAccessToken" Category="WopiCore">
        <Description>
          Tests that GetRootContainer denies requests with invalid access tokens.
        </Description>
        <Requests>
          <GetEcosystem>
            <SaveState>
              <State Name="EcosystemUrl" Source="Url" />
            </SaveState>
          </GetEcosystem>
          <GetRootContainer OverrideUrl="$State:EcosystemUrl" WopiSrc="$State:OriginalWopiEndpoint">
            <Mutators>
              <AccessToken Mutation="INVALID" />
            </Mutators>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="401" />
                <ResponseCodeValidator ExpectedCode="404" />
              </Or>
            </Validators>
          </GetRootContainer>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains Containers test cases -->
  <TestGroup Name="Container">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>UserCanWritePrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /containers/CheckContainerInfo -->
      <TestCase Name="containers.CheckContainerInfo" Category="WopiCore">
        <Description>
          Tests that CheckContainerInfo returns a valid response.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="HostUrl" />
                <AbsoluteUrlProperty Name="SharingUrl" />
                <BooleanProperty Name="UserCanCreateChildFile" />
                <BooleanProperty Name="UserCanCreateChildContainer" />
                <BooleanProperty Name="UserCanDelete" />
                <BooleanProperty Name="UserCanRename" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
        </Requests>
      </TestCase>

      <!-- /containers/CreateChildContainer -->
      <!-- /containers/DeleteContainer -->
      <TestCase Name="containers.CreateAndDeleteChildContainer" Category="WopiCore">
        <Description>
          Tests creating a child container and deleting it.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="containers.CreateAndDeleteChildContainerDupe" Category="WopiCore">
        <Description>
          Tests that CreateChildContainer handles 'suggested mode' properly.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolder2Url" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
          <DeleteContainer OverrideUrl="$State:NewFolder2Url" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
          <DeleteContainer OverrideUrl="$State:NewFolder2Url" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="containers.CreateAndDeleteChildContainerExactName" Category="WopiCore">
        <Description>
          Tests that CreateChildContainer handles 'specific mode' properly.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="ExactName">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="containers.CreateAndDeleteChildContainerExactNameDupe" Category="WopiCore">
        <Description>
          Tests that CreateChildContainer handles conflicting container names when in 'specific mode' properly.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="ExactName">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="ExactName">
            <SaveState>
              <State Name="NewFolder2Url" Source="ContainerPointer.Url" />
            </SaveState>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </CreateChildContainer>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
          <DeleteContainer OverrideUrl="$State:NewFolder2Url" />
        </CleanupRequests>
      </TestCase>

      <!-- /containers/GetEcosystem -->
      <TestCase Name="containers.GetEcosystem" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/GetEcosystem on each element</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <GetEcosystem OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetEcosystem>
        </Requests>
      </TestCase>

      <TestCase Name="containers.LicensingPropertiesOnChildFolderMatchWithParentFolder" Category="OfficeNativeClient">
        <Description>
          Verify that some CheckContainerInfo user properties match between a child container and its parent.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <SaveState>
              <State Name="LicenseCheckForEditIsEnabledParentContainer" Source="LicenseCheckForEditIsEnabled" />
              <State Name="IsEduUserParentContainer" Source="IsEduUser" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" />
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" />
                <BooleanProperty Name="LicenseCheckForEditIsEnabled" IsRequired="true" />
                <BooleanProperty Name="IsEduUser" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="testfolder" PutRelativeFileMode="ExactName">
            <SaveState>
              <State Name="TestChildFolder" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <CheckContainerInfo OverrideUrl="$State:TestChildFolder">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="LicenseCheckForEditIsEnabled" ExpectedStateKey="LicenseCheckForEditIsEnabledParentContainer" IsRequired="true" />
                <BooleanProperty Name="IsEduUser" ExpectedStateKey="IsEduUserParentContainer" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:TestChildFolder" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains Container rename test cases -->
  <TestGroup Name="RenameContainer">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>UserCanWritePrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>UserCanRenameContainerPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /containers/RenameContainer -->
      <TestCase Name="containers.CreateAndRenameChildContainer" Category="WopiCore">
        <Description>
          Tests that RenameContainer is handled properly.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <RenameContainer OverrideUrl="$State:NewFolderUrl" Name="RenameContainerTest" />
          <CheckContainerInfo OverrideUrl="$State:NewFolderUrl">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" ExpectedValue="RenameContainerTest" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="containers.CreateAndRenameChildContainerAndVerifyReturnedContainerNameIsCorrectlyEncoded" Category="WopiCore">
        <Description>
          Tests the Containers.RenameChildContainer scenario where a Relative name is specified. Expect the host to rename
          the container with the exact name as specified. Also ensure that the host returns a UTF-8 encoded version of the ContainerName.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <RenameContainer OverrideUrl="$State:NewFolderUrl" Name="container_name" />
          <CheckContainerInfo OverrideUrl="$State:NewFolderUrl">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" ExpectedValue="container_name" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains EnumerateAncestors and EnumerateChildren test cases -->
  <TestGroup Name="EnumerateAncestorsAndChildren">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /files/EnumerateAncestors -->
      <TestCase Name="files.EnumerateAncestors" Category="WopiCore">
        <Description>just EnumerateAncestors</Description>
        <Requests>
          <EnumerateAncestors>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="AncestorsWithRootFirst[0].Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="AncestorsWithRootFirst[0].Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </EnumerateAncestors>
        </Requests>
      </TestCase>

      <!-- /containers/EnumerateChildren -->
      <TestCase Name="containers.EnumerateChildren" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateChildren on the parent folder</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <EnumerateChildren OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ChildFiles[0].Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="ChildFiles[0].Url" IsRequired="true" MustIncludeAccessToken="true" />
                <StringProperty Name="ChildFiles[0].Version" IsRequired="true" />
                <LongProperty Name="ChildFiles[0].Size" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </EnumerateChildren>
        </Requests>
      </TestCase>

      <TestCase Name="containers.EnumerateChildrenOnRoot" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateChildren on the root folder</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[0].Url" />
            </SaveState>
          </EnumerateAncestors>
          <EnumerateChildren OverrideUrl="$State:ParentContainerUrl">
            <!-- We can't know whether there will be files or folders in an arbitrary host's root, so we can't validate. -->
          </EnumerateChildren>
        </Requests>
      </TestCase>

      <TestCase Name="containers.EnumerateChildrenWithOneFilter" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateChildren on the parent folder with a file extension filter</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <EnumerateChildren OverrideUrl="$State:ParentContainerUrl" FileExtensionFilterList=".wopitest">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ChildFiles[0].Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="ChildFiles[0].Url" IsRequired="true" MustIncludeAccessToken="true" />
                <StringProperty Name="ChildFiles[0].Version" IsRequired="true" />
                <LongProperty Name="ChildFiles[0].Size" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </EnumerateChildren>
        </Requests>
      </TestCase>

      <TestCase Name="containers.EnumerateChildrenWithMultipleFilters" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateChildren on the parent folder with multiple file extensions filtered</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <EnumerateChildren OverrideUrl="$State:ParentContainerUrl" FileExtensionFilterList=".wopitest,.docx,.xlsx">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ChildFiles[0].Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="ChildFiles[0].Url" IsRequired="true" MustIncludeAccessToken="true" />
                <StringProperty Name="ChildFiles[0].Version" IsRequired="true" />
                <LongProperty Name="ChildFiles[0].Size" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </EnumerateChildren>
        </Requests>
      </TestCase>

      <!-- /containers/EnumerateAncestors -->
      <TestCase Name="containers.EnumerateAncestorsOnRoot" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateAncestors on a container which is a root container</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[0].Url" />
            </SaveState>
          </EnumerateAncestors>
          <EnumerateAncestors OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </EnumerateAncestors>
        </Requests>
      </TestCase>

      <!-- /containers/EnumerateAncestors -->
      <TestCase Name="containers.EnumerateAncestorsOnChildren" Category="WopiCore">
        <Description>/files/EnumerateAncestors then /containers/EnumerateAncestors on a container which is not a root container</Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildContainer" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildContainer OverrideUrl="$State:ParentContainerUrl" FolderName="CreateChildContainerTest" PutRelativeFileMode="Suggested">
            <SaveState>
              <State Name="NewFolderUrl" Source="ContainerPointer.Url" />
            </SaveState>
          </CreateChildContainer>
          <EnumerateAncestors OverrideUrl="$State:NewFolderUrl">
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="AncestorsWithRootFirst[0].Name" IsRequired="true" />
                <AbsoluteUrlProperty Name="AncestorsWithRootFirst[0].Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </EnumerateAncestors>
        </Requests>
        <CleanupRequests>
          <DeleteContainer OverrideUrl="$State:NewFolderUrl" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify CreateChildFile and DeleteFile -->
  <TestGroup Name="CreateChildFileAndDeleteFile">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>UserCanWritePrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>DeleteFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /containers/CreateChildFile -->
      <!-- /files/DeleteFile -->
      <TestCase Name="CreateChildFileAndDelete" Category="WopiCore">
        <Description>
          /files/EnumerateAncestors then go to a container that has UserCanCreateChildFile=true.
          create a file.  delete it.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="Suggested" Name="CreateChildFileTestFile.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
          </CreateChildFile>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </Requests>
      </TestCase>

      <TestCase Name="CreateChildFile.SuggestedName" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a suggested name is specified.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="Suggested" Name="madeupname.wopitest">
            <SaveState>
              <State Name="NewFileUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewFileUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.SuggestedNameConflict" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a suggested name is specified but
          a file with the target name already exists. Expect the request to succeed with the host
          choosing a suitable name.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="Suggested" Name="madeupname.wopitest">
            <SaveState>
              <State Name="NewUrl1" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="Suggested" Name="madeupname.wopitest">
            <SaveState>
              <State Name="NewUrl2" Source="Url" />
            </SaveState>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith="wopitest" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl1" />
          <DeleteFile OverrideUrl="$State:NewUrl2" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeName" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified. Expect the host to create
          a new file with the exact name as specified.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameOverwriteTrueNoEffect" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified and OverwriteRelative
          is set to true. Since no file with target name exists in this scenario, the header should have
          no effect. Expect the host to create a new file with the exact name as specified.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" OverwriteRelative="true">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameOverwriteFalseNoEffect" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified and OverwriteRelative
          is set to false. Since no file with target name exists in this scenario, the header should have
          no effect. Expect the host to create a new file with the exact name as specified.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" OverwriteRelative="false">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameConflictNoOverwrite" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified and OverwriteRelative
          is not specified. Since a file with target name exists in this scenario, expect the host to
          return 409 status code as conflict.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameConflictOverwriteFalse" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified and OverwriteRelative
          is set to false. Since a file with target name exists in this scenario, expect the host to
          return 409 status code as conflict.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" OverwriteRelative="false">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameConflictOverwriteTrue" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified and OverwriteRelative
          is set to true. Since a file with target name exists in this scenario, expect the host to
          succeed by choosing a suitable name.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl1" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" OverwriteRelative="true">
            <SaveState>
              <State Name="NewUrl2" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="Name" EndsWith=".wopitestx" IsRequired="true" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewUrl2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </CheckFileInfo>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl1" />
          <DeleteFile OverrideUrl="$State:NewUrl2" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.ConflictingHeaders" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where both a suggested name and a relative name are specified.
          Expect the host to fail the request as bad request.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="Conflicting" Name="madeupname.wopitestx">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </CreateChildFile>
        </Requests>
      </TestCase>

      <TestCase Name="CreateChildFile.RelativeNameConflictOverwriteTrueLocked" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a relative name is specified along with OverwriteRelative
          set to true, but a file with the same target name already exists and is locked. Expect the host
          to fail the request with a 409 conflict code.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
                <AbsoluteUrlProperty Name="HostViewUrl" IsRequired="false" />
                <AbsoluteUrlProperty Name="HostEditUrl" IsRequired="false" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <Lock Lock="LockString" OverrideUrl="$State:NewUrl" />
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx" OverwriteRelative="true">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" OverrideUrl="$State:NewUrl" />
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.FileNameReturnedIsCorrectlyEncoded" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a Relative name is specified. Expect the host to create
          a new file with the exact name as specified. Also ensure that the host returns a UTF-8 encoded version of the FileName.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeup_name.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeup_name.wopitestx" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.FileNameLongerThan512Characters" Category="WopiCore">
        <Description>
          Tests the Containers.CreateChildFile scenario where a file name is longer than 512 characters, then the host should return a 400 or 200.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="longwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilenamelongwopitestfilename.wopitestx">
            <SaveState>
              <State Name="UrlWithFileNameLongerThan512Chars" Source="Url" />
            </SaveState>
            <Validators>
              <Or>
                <ResponseCodeValidator ExpectedCode="400" />
                <ResponseCodeValidator ExpectedCode="200" />
              </Or>
            </Validators>
          </CreateChildFile>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:UrlWithFileNameLongerThan512Chars" />
        </CleanupRequests>
      </TestCase>

      <TestCase Name="CreateChildFile.LicensingPropertiesOnChildFileMatchWithParentFolder" Category="OfficeNativeClient">
        <Description>
          Verify that some CheckContainerInfo and CheckFileInfo user properties match between a child file and its parent container.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl">
            <SaveState>
              <State Name="LicenseCheckForEditIsEnabledParentContainer" Source="LicenseCheckForEditIsEnabled" />
              <State Name="IsEduUserParentContainer" Source="IsEduUser" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="UserCanCreateChildFile" ExpectedValue="true" IsRequired="true" />
                <BooleanProperty Name="LicenseCheckForEditIsEnabled" IsRequired="true" />
                <BooleanProperty Name="IsEduUser" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckContainerInfo>
          <CreateChildFile OverrideUrl="$State:ParentContainerUrl" PutRelativeFileMode="ExactName" Name="madeupname.wopitestx">
            <SaveState>
              <State Name="NewUrl" Source="Url" />
            </SaveState>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="madeupname.wopitestx" />
                <AbsoluteUrlProperty Name="Url" IsRequired="true" MustIncludeAccessToken="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CreateChildFile>
          <CheckFileInfo OverrideUrl="$State:NewUrl">
            <Validators>
              <JsonResponseContentValidator>
                <BooleanProperty Name="LicenseCheckForEditIsEnabled" ExpectedStateKey="LicenseCheckForEditIsEnabledParentContainer" IsRequired="true" />
                <BooleanProperty Name="IsEduUser" ExpectedStateKey="IsEduUserParentContainer" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
        <CleanupRequests>
          <DeleteFile OverrideUrl="$State:NewUrl" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="FileUrlUsage">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>UserCanWritePrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>FileUrlUsagePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="GetFromFileUrlAfterPutFile" Document="WordBlankDocument" Category="WopiCore">
        <Description>
          Tests that the FileUrl returns updated content after a PutFile request, since FileUrl is intended to be a drop in replacement for GetFile.
        </Description>
        <Requests>
          <CheckFileInfo>
            <SaveState>
              <State Name="FileUrl" Source="FileUrl" />
            </SaveState>
          </CheckFileInfo>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetFromFileUrl OverrideUrl="$State:FileUrl">
            <Validators>
              <ResponseContentValidator ExpectedResourceId="WordSimpleDocument" />
            </Validators>
          </GetFromFileUrl>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="LockString" />
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="FileUrlViewOnly">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileUrlUsagePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="GetFromFileUrl" Document="WordBlankDocument" Category="WopiCore">
        <Description>
          Use FileUrl, if provided, to directly retrieve the contents of a file instead of using GetFile.
        </Description>
        <Requests>
          <CheckFileInfo>
            <SaveState>
              <State Name="FileUrl" Source="FileUrl" />
            </SaveState>
          </CheckFileInfo>
          <GetFromFileUrl OverrideUrl="$State:FileUrl">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetFromFileUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForFileWithTypeReadOnly">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ShareUrlTypeReadOnlyForFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="files.GetShareUrlForReadOnlyUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a file where the requested share url type is "ReadOnly".
        </Description>
        <Requests>
          <CheckFileInfo />
          <GetShareUrl UrlType="ReadOnly">
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="ShareUrl" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForFileWithTypeReadWrite">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ShareUrlTypeReadWriteForFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="files.GetShareUrlForReadWriteUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a file where the requested share url type is "ReadWrite".
        </Description>
        <Requests>
          <CheckFileInfo />
          <GetShareUrl UrlType="ReadWrite">
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="ShareUrl" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForFileWithUnknownType">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportedShareUrlTypesForFilePrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="files.GetShareUrlForUnknownUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a file where the requested share url type is unknown.
        </Description>
        <Requests>
          <CheckFileInfo />
          <GetShareUrl UrlType="UnknownType">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForContainerWithTypeReadOnly">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>ShareUrlTypeReadOnlyForContainerPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="containers.GetShareUrlForReadOnlyUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a container where the requested share url type is "ReadOnly".
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl" />
          <GetShareUrl OverrideUrl="$State:ParentContainerUrl" UrlType="ReadOnly">
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="ShareUrl" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForContainerWithTypeReadWrite">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>ShareUrlTypeReadWriteForContainerPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="containers.GetShareUrlForReadWriteUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a container where the requested share url type is "ReadWrite".
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl" />
          <GetShareUrl OverrideUrl="$State:ParentContainerUrl" UrlType="ReadWrite">
            <Validators>
              <JsonResponseContentValidator>
                <AbsoluteUrlProperty Name="ShareUrl" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="GetSharingUrlForContainerWithUnknownType">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>ContainersPrereq</PrereqTest>
      <PrereqTest>SupportedShareUrlTypesForContainerPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="containers.GetShareUrlForUnknownUrlType" Category="WopiCore">
        <Description>
          Tests the GetShareUrl operation for a container where the requested share url type is unknown.
        </Description>
        <Requests>
          <EnumerateAncestors>
            <SaveState>
              <!-- Save the Url property of the last child of AncestorsWithRootFirst -->
              <State Name="ParentContainerUrl" Source="AncestorsWithRootFirst[-1:].Url" />
            </SaveState>
          </EnumerateAncestors>
          <CheckContainerInfo OverrideUrl="$State:ParentContainerUrl" />
          <GetShareUrl OverrideUrl="$State:ParentContainerUrl" UrlType="UnknownType">
            <Validators>
              <ResponseCodeValidator ExpectedCode="501" />
            </Validators>
          </GetShareUrl>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains AddActivities test cases -->
  <TestGroup Name="AddActivities">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>AddActivitiesPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <!-- /files/AddActivities -->
      <TestCase Name="files.AddActivitiesSingleMinimalComment" Category="WopiCore">
        <Description>one comment, minimal properties</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000014-0000-0000-0000-000000000000",
                "Timestamp": "2017-03-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000014-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesSingleFullComment" Category="WopiCore">
        <Description>one comment with all data properties set</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000001-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "CommentText": "basic text",
                  "ContentId": "cid123",
                  "NavigationId": "nid123",
                  "ContentAction": "created",
                  "IsReply": true
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000001-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesAllCapsID" Category="WopiCore">
        <Description>one comment with all-caps ID GUID</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000002-ABCD-ABCD-ABCD-ABCDEFABCDEF",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000002-ABCD-ABCD-ABCD-ABCDEFABCDEF" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesMaxLengthContentID" Category="WopiCore">
        <Description>one comment with max-length ContentID</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000004-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000004-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesMaxLengthNavigationId" Category="WopiCore">
        <Description>one comment with max-length NavigationId</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000005-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "NavigationId": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000005-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentUpdate" Category="WopiCore">
        <Description>one comment with ContentAction=update</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000006-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "updated"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000006-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentDelete" Category="WopiCore">
        <Description>one comment with ContentAction=delete</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000007-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "deleted"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000007-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesWithBonusToplevelProperty" Category="WopiCore">
        <Description>one comment with bogus additional toplevel property</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000008-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                },
                "BonusTopLevelProperty": "future compatibility!"
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000008-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesWithBonusDataProperty" Category="WopiCore">
        <Description>one comment with bogus additional data property</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000003-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created",
                  "BonusProperty": "future compatibility!"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000003-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentAndPerson" Category="WopiCore">
        <Description>one comment, one person</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000009-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                },
                "People": [
                  {
                    "Name": "John Able",
                    "Id": "111",
                    "Provider": "wopi-contoso",
                    "Mentioned": true
                  }
                ]
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000009-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentWithThreePeople" Category="WopiCore">
        <Description>one comment, three people</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "0000000a-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                },
                "People": [
                  {
                    "Name": "John Able",
                    "Id": "111",
                    "Provider": "wopi-contoso",
                    "Mentioned": true
                  },
                  {
                    "Name": "Jane Baker",
                    "Id": "222",
                    "Provider": "wopi-contoso",
                    "InThread": true
                  },
                  {
                    "Name": "Pat Charlie",
                    "Id": "333",
                    "Provider": "wopi-contoso",
                    "InThread": true,
                    "RepliedTo": true
                  }
                ]
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000a-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentWithPersonBonusProperty" Category="WopiCore">
        <Description>one comment, one person with bogus additional property</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "0000000b-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                },
                "People": [
                  {
                    "Name": "John Able",
                    "Id": "111",
                    "Provider": "wopi-contoso",
                    "Mentioned": true,
                    "BonusProperty": "future compatibility!"
                  }
                ]
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000b-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesCommentWithNonWopiPerson" Category="WopiCore">
        <Description>one comment, one person with non-wopi provider and ID</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "0000000c-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                },
                "People": [
                  {
                    "Name": "Don Delta",
                    "Id": "{00000000-0000-0000-0000-000000000000}",
                    "Provider": "Windows Live",
                    "Mentioned": true
                  }
                ]
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000c-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesUnknownActivityType" Category="WopiCore">
        <Description>one activity with bogus type</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "unsupported",
                "Id": "0000000d-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000d-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <JsonResponseContentValidator>
                <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
              </JsonResponseContentValidator>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesUnknownNoDataActivity" Category="WopiCore">
        <Description>one activity with bogus type and no data</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "unsupported",
                "Id": "0000000e-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z"
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000e-0000-0000-0000-000000000000" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesTwoActivitiesOneUnknown" Category="WopiCore">
        <Description>one comment and one activity with bogus type</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "0000000f-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              },
              {
                "Type": "unsupported",
                "Id": "00000010-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <Or>
                <!-- We don't know what order they'll come back in so we need to OR and check both ways -->
                <JsonResponseContentValidator>
                  <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="0000000f-0000-0000-0000-000000000000" />
                  <StringProperty Name="ActivityResponses[1].Id" IsRequired="true" ExpectedValue="00000010-0000-0000-0000-000000000000" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" ExpectedValue="00000010-0000-0000-0000-000000000000" />
                  <StringProperty Name="ActivityResponses[1].Id" IsRequired="true" ExpectedValue="0000000f-0000-0000-0000-000000000000" />
                </JsonResponseContentValidator>
              </Or>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[1].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[1].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

      <TestCase Name="files.AddActivitiesThreeComments" Category="WopiCore">
        <Description>three comments</Description>
        <Requests>
          <AddActivities>
            <RequestBody>
              <![CDATA[{ "Activities": [
              {
                "Type": "comment",
                "Id": "00000011-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              },
              {
                "Type": "comment",
                "Id": "00000012-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              },
              {
                "Type": "comment",
                "Id": "00000013-0000-0000-0000-000000000000",
                "Created": "2017-02-15T13:47:13000000Z",
                "Data": {
                  "ContentId": "cid123",
                  "ContentAction": "created"
                }
              }
              ] }]]>
            </RequestBody>
            <Validators>
              <!-- We don't know what order they'll come back in and checking each possibility is too much so we'll just make sure that we got three replies -->
              <JsonResponseContentValidator>
                <StringProperty Name="ActivityResponses[0].Id" IsRequired="true" />
                <StringProperty Name="ActivityResponses[1].Id" IsRequired="true" />
                <StringProperty Name="ActivityResponses[2].Id" IsRequired="true" />
              </JsonResponseContentValidator>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[0].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[1].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[1].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
              <Or>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[2].Status" ExpectedValue="0" />
                </JsonResponseContentValidator>
                <JsonResponseContentValidator>
                  <IntegerProperty Name="ActivityResponses[2].Status" ExpectedValue="3" />
                </JsonResponseContentValidator>
              </Or>
            </Validators>
          </AddActivities>
        </Requests>
      </TestCase>

    </TestCases>
  </TestGroup>

  <!-- Proof key related test cases -->
  <TestGroup Name="ProofKeys">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="ProofKeys.CurrentValid.OldValid" Category="OfficeOnline">
        <Description>
          Tests that hosts accept requests where the X-WOPI-Proof value is correctly signed with the current proof key,
          and the X-WOPI-ProofOld value is signed with the old proof key.
        </Description>
        <Requests>
          <CheckFileInfo />
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.CurrentValid.OldInvalid" Category="OfficeOnline">
        <Description>
          Tests that hosts accept requests where the X-WOPI-Proof value is correctly signed with the current proof key,
          but the X-WOPI-ProofOld value is invalid. This scenario is unusual and should not happen in a production
          environment, but since the X-WOPI-Proof value is signed with the current public key, the request should be
          accepted.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey MutateOld="true" />
            </Mutators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.CurrentInvalid.OldValidSignedWithCurrentKey" Category="OfficeOnline">
        <Description>
          Tests that hosts accept requests where the X-WOPI-Proof value is invalid but the X-WOPI-ProofOld value is
          signed with current public key. This can happen when a WOPI client such as Office Online has rotated proof keys
          but the host hasn't re-run WOPI discovery yet.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey KeyRelation="Ahead" />
            </Mutators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.CurrentValidSignedWithOldKey.OldInvalid" Category="OfficeOnline">
        <Description>
          Tests that hosts accept requests where the X-WOPI-ProofOld value is invalid but the X-WOPI-Proof value is
          signed with old public key. This can happen when a WOPI client has rotated proof keys, the host has re-run
          WOPI discovery and has the updated keys, but the datacenter machine making the WOPI request does not yet have
          the updated keys.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey KeyRelation="Behind" />
            </Mutators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.CurrentInvalid.OldValidSignedWithOldKey" Category="OfficeOnline">
        <Description>
          Tests that hosts reject requests where the X-WOPI-Proof value is invalid, and the X-WOPI-ProofOld value
          is signed with the old public key. This scenario is unusual and should not happen in a production
          environment; such requests should be rejected.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey MutateCurrent="true" />
            </Mutators>
            <Validators>
              <ResponseCodeValidator ExpectedCode="500" />
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.CurrentInvalid.OldInvalid" Category="OfficeOnline">
        <Description>
          Tests that hosts reject requests with invalid current and old proof keys.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey MutateCurrent="true" MutateOld="true" />
            </Mutators>
            <Validators>
              <ResponseCodeValidator ExpectedCode="500" />
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

      <TestCase Name="ProofKeys.TimestampOlderThan20Min" Category="OfficeOnline">
        <Description>
          Tests that hosts reject requests with an X-WOPI-Timestamp value that represents a time more than 20 minutes old.
        </Description>
        <Requests>
          <CheckFileInfo>
            <Mutators>
              <ProofKey Timestamp="2015-08-17T00:00:00Z" />
            </Mutators>
            <Validators>
              <ResponseCodeValidator ExpectedCode="500" />
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>

    </TestCases>
  </TestGroup>

  <TestGroup Name="CoauthLocks">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="CoauthLock.SingleLockInCoauthTable" Category="WopiCoauth">
        <Description>
          Tests that a single coauth lock is requested and is reflected in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="SingleLockInCoauthTable" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'SingleLockInCoauthTable', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.SingleLockInCoauthTable.GetCoauthTableWithSameVersionAsHost" Category="WopiCoauth">
        <Description>
          Initiates GetCoauthTable request with the same CoathTableVersion as host, host returns no response body.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="SingleLockInCoauthTable" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthTable CoauthTableVersionStateKey="CoauthTableVersionStateOverride">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonResponseContentValidator ShouldExist="false" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" />
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockRequestOnSameCoauthLockExpirationRefresh" Category="WopiCoauth">
        <Description>
          Tests that a coauth lock's expiration timeout is refreshed when requested with the same coauth lock id as an already existing coauth lock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnSameCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnSameCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'CoauthLockRequestOnSameCoauthLock', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthExclusiveLockRequestOnExistingCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that a coauth exclusive lock request replaces the lock type of a coauth lock of the same id.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthExclusiveLockRequestOnExistingCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthExclusiveLockRequestOnExistingCoauthLock" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'CoauthExclusiveLockRequestOnExistingCoauthLock', CoauthLockType:'CoauthExclusive', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.UnlockCoauthLockValidation" Category="WopiCoauth">
        <Description>
          Tests that an unlock coauth lock request unlocks the coauth lock from the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="UnlockCoauthLockValidation" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="0" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.MultipleLocksInCoauthTable" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks are requested and are reflected in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'MultipleLocksInCoauthTable1', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}, {CoauthLockId:'Client2', CoauthLockMetadata:'MultipleLocksInCoauthTable2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="2" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.MultipleLocksInCoauthTable.GetCoauthTableWithDifferentVersionFromHost" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks are requested, then GetCoauthTable with different CoauthTableVersion from host, CoauthTable will be returned.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_1" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride_1" ShouldMatch="false" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_2" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthTable CoauthTableVersionStateKey="CoauthTableVersionStateOverride_1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'MultipleLocksInCoauthTable1', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}, {CoauthLockId:'Client2', CoauthLockMetadata:'MultipleLocksInCoauthTable2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="2" IsRequired="true" />
              </JsonResponseContentValidator>
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride_2" ShouldMatch="true" />
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.MultipleLocksInCoauthTable.GetCoauthTableWithSameVersionAsHost" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks are requested, then GetCoauthTable with same CoauthTableVersion as host, no response body returned.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_1" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleLocksInCoauthTable2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride_1" ShouldMatch="false" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_2" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthTable CoauthTableVersionStateKey="CoauthTableVersionStateOverride_2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator ShouldExist="false" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride_2" ShouldMatch="true" />
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.UnlockCoauthLockWithMultipleLocksInCoauthTable" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks and coauth unlocks are requested and are reflected in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="UnlockCoauthLockWithMultipleLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="UnlockCoauthLockWithMultipleLocksInCoauthTable2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client2', CoauthLockMetadata:'UnlockCoauthLockWithMultipleLocksInCoauthTable2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.MultipleTypesOfLocksInCoauthTable" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks of different types can exist in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleTypesOfLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleTypesOfLocksInCoauthTable2" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockType:'CoauthExclusive', CoauthLockId:'Client2', CoauthLockMetadata:'MultipleTypesOfLocksInCoauthTable2', UserFriendlyName:'*', CoauthLockTime:'*'}, {CoauthLockId:'Client1', CoauthLockMetadata:'MultipleTypesOfLocksInCoauthTable1', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="2" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.MultipleTypesOfLocksInCoauthTable.GetCoauthTableWithSameVersionAsHost" Category="WopiCoauth">
        <Description>
          Tests that multiple coauth locks of different types exist on the coauth table, then GetCoauthTable requested with same CoauthTableVersion as host, no response body returned.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleTypesOfLocksInCoauthTable1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_1" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="MultipleTypesOfLocksInCoauthTable2" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride_1" ShouldMatch="false" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride_2" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthTable CoauthTableVersionStateKey="CoauthTableVersionStateOverride_2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonResponseContentValidator ShouldExist="false" />
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.GetCoauthTableWithoutLocks" Category="WopiCoauth">
        <Description>
          Tests that the coauth table request will return an empty array if there aren't any coauth locks.
        </Description>
        <Requests>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedValue="" ShouldMatch="false" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="0" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockRequestOnExistingCoauthExclusiveLockOfSameCoauthLockId" Category="WopiCoauth">
        <Description>
          Tests when a coauth lock is requested with the same coauth lock id as an existing coauth exclusive lock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnExistingCoauthExclusiveLockOfSameCoauthLockId" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnExistingCoauthExclusiveLockOfSameCoauthLockId" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'CoauthLockRequestOnExistingCoauthExclusiveLockOfSameCoauthLockId', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockRequestOnExistingCoauthExclusiveLockOfDifferentCoauthLockId" Category="WopiCoauth">
        <Description>
          Tests when a coauth lock is requested with a different coauth lock id when a coauth exclusive lock already exists.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnExistingCoauthExclusiveLockOfDifferentCoauthLockId1" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnExistingCoauthExclusiveLockOfDifferentCoauthLockId2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'CoauthLockRequestOnExistingCoauthExclusiveLockOfDifferentCoauthLockId1', CoauthLockType:'CoauthExclusive', UserFriendlyName:'*', CoauthLockTime:'*'},{CoauthLockId:'Client2', CoauthLockMetadata:'CoauthLockRequestOnExistingCoauthExclusiveLockOfDifferentCoauthLockId2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="2" IsRequired="true" />
            </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockMetadataValidation" Category="WopiCoauth">
        <Description>
          Tests that the response of the coauth lock metadata is set from the passed metadata header.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthMetadataValidation" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'CoauthMetadataValidation', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.EmptyCoauthLockMetadata" Category="WopiCoauth">
        <Description>
          Tests that the response of the coauth lock metadata is empty if the metadata header is empty.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.OmittedCoauthLockMetadata" Category="WopiCoauth">
        <Description>
          Tests that the response of the coauth lock metadata is empty if the metadata header is omitted.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockWithMetadata" Category="WopiCoauth">
        <Description>
          Tests that a refresh coauth lock request with new metadata passed changes the metadata for the coauth lock in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockWithMetadata1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockWithMetadata2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="false" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'RefreshCoauthLockWithMetadata2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </RefreshCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>      
      <TestCase Name="CoauthLock.RefreshCoauthLockWithoutMetadata" Category="WopiCoauth">
        <Description>
          Tests that a refresh coauth lock request without metadata passed has no effect on the coauth lock metadata.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockWithoutMetadata" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="CoauthTableVersionStateOverride" Source="X-WOPI-CoauthTableVersion" SourceType="Header" />
            </SaveState>
          </GetCoauthLock>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" ExpectedStateKey="CoauthTableVersionStateOverride" ShouldMatch="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'RefreshCoauthLockWithoutMetadata', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </RefreshCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.GetCoauthLockWithoutCoauthLockType" Category="WopiCoauth">
        <Description>
          Tests the failing of GetCoauthLock requests when missing the required parameter of CoauthLockType.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="GetCoauthLockWithoutCoauthLockType">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.GetCoauthLockWithoutCoauthLockId" Category="WopiCoauth">
        <Description>
          Tests the failing of GetCoauthLock requests when missing the required parameter of CoauthLockId.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockExpirationTimeout="120" CoauthLockMetadata="GetCoauthLockWithoutCoauthLockId" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
        <TestCase Name="CoauthLock.GetCoauthLockWithoutCoauthLockExpirationTimeout" Category="WopiCoauth">
        <Description>
          Tests the failing of GetCoauthLock requests when missing the required parameter of CoauthLockExpirationTimeout.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockMetadata="GetCoauthLockWithoutCoauthLockExpirationTimeout" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.UnlockCoauthLockWithoutCoauthLockId" Category="WopiCoauth">
        <Description>
          Tests the failing of UnlockCoauth requests when missing the required parameter of CoauthLockId.
        </Description>
        <Requests>
          <UnlockCoauthLock>
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </UnlockCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockWithoutCoauthLockId" Category="WopiCoauth">
        <Description>
          Tests the failing of RefreshCoauthLock requests when missing the required parameter of CoauthLockId.
        </Description>
        <Requests>
          <RefreshCoauthLock CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockWithoutCoauthLockId">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockWithoutCoauthLockExpirationTimeout" Category="WopiCoauth">
        <Description>
          Tests the failing of RefreshCoauthLock requests when missing the required parameter of CoauthLockExpirationTimeout.
        </Description>
        <Requests>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockMetadata="RefreshCoauthLockWithoutCoauthLockExpirationTimeout">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.InvalidCoauthLockType" Category="WopiCoauth">
        <Description>
          Tests when the coauth lock type is set to "None" instead of "Coauth" or "CoauthExclusive."
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockTypeValidation" CoauthLockType="None">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.EmptyCoauthLockType" Category="WopiCoauth">
        <Description>
          Tests when the coauth lock type is empty.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="EmptyCoauthLockType" CoauthLockType="">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockIdLengthValidationForGetCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that the CoauthLockId parameter is outside size limitations of 1024 ASCII characters for GetCoauthLock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="I1Iewhc0FUhHUVls6NPv9hnpzEmwRsTyZUBPxMDN8RTpNkLE1kbjDom8GGmpDh5XJOyOMK9e8Hly3KCNU8ojEk8mszGvXqOc1eQqady0S2VF7aWpkP35aVnCB9l7ZOadEzS36hrW9VQPpuNaXPk5pXHyngG9Aew5RmH5d6Ll5upwK6N29jYDRywJttG8WIWoGsxRiBGw70zEdftRvY0jTGkTHdxiueTJypFQh2VeDxfIktneGb8uJ9snWxdseZPdnUMUvI10uv0IDDL81vgpOi2eKnq7XJSaAq0CxoUO3Sx8QnRqBPzYp4QqzjXPLzogjtx1fBsFSoqYj5xUpiad2wSxYxOMjoqRIW1lxXDaJQcPmtfVfdvwpDYp44ahsHfM32lNk5lw0qUQxhGSZ699ku7RaZqMkfiesw8sozXrtZ1vd0lyuqQcUusIXna0U395qKxQO7XYiz3YVg88SJMn9BnDy7ZRUv177yb8GDlEN7By1KaIR7GxGIDx0HRmdivxxkuJGV6rEn21RPhJarislilveHl6A4hffbnjVKXZNZdkvsOL2QsWPbzA25qarXJVeBIjOjeyyjOLCxtHtyQwRaE8U2jbx9qIt2d3R69Fz4wq4rf6uWhk39FyuXxIFADEtOHiwJ7vrYOepgNCMyRedTbvjjUVRDPGuhswwFpDVrOqkiRrCfIZwyjRar3XZmEeoxweEGCVB6kzfKA1YQGxpWkMXdnWxY3sDimOZQBKG6r24buzhkSOmkWoxeZWnSvqF4ZagEMVkdZ0KOzr9Y8D27pu9LVQERPSBwgocRjV5jktzhrbFgr115aXkvTzOTxw5pSxqTCkifdzr6Ub6K5Q4xQsi4Ar6VS7ZLxX61hfoLwJVHRM1N5gQnsP3FiOxNwkJguU7T1THJJ1EcSdhJOSCKONOoOvVqQ2pAcQTYcbAVO18jzqN0G1b1lFO7jKmxBkmI4l4eKbLIDYWvOicvKh9hYkoKJMkmHqCeXYFSqiVSRdwIvV16kfXeRmXzKl0jNft" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockIdLengthValidationForGetCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockIdLengthValidationForUnlockCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that the CoauthLockId parameter is outside size limitations of 1024 ASCII characters for UnlockCoauthLock.
        </Description>
        <Requests>
          <UnlockCoauthLock CoauthLockId="I1Iewhc0FUhHUVls6NPv9hnpzEmwRsTyZUBPxMDN8RTpNkLE1kbjDom8GGmpDh5XJOyOMK9e8Hly3KCNU8ojEk8mszGvXqOc1eQqady0S2VF7aWpkP35aVnCB9l7ZOadEzS36hrW9VQPpuNaXPk5pXHyngG9Aew5RmH5d6Ll5upwK6N29jYDRywJttG8WIWoGsxRiBGw70zEdftRvY0jTGkTHdxiueTJypFQh2VeDxfIktneGb8uJ9snWxdseZPdnUMUvI10uv0IDDL81vgpOi2eKnq7XJSaAq0CxoUO3Sx8QnRqBPzYp4QqzjXPLzogjtx1fBsFSoqYj5xUpiad2wSxYxOMjoqRIW1lxXDaJQcPmtfVfdvwpDYp44ahsHfM32lNk5lw0qUQxhGSZ699ku7RaZqMkfiesw8sozXrtZ1vd0lyuqQcUusIXna0U395qKxQO7XYiz3YVg88SJMn9BnDy7ZRUv177yb8GDlEN7By1KaIR7GxGIDx0HRmdivxxkuJGV6rEn21RPhJarislilveHl6A4hffbnjVKXZNZdkvsOL2QsWPbzA25qarXJVeBIjOjeyyjOLCxtHtyQwRaE8U2jbx9qIt2d3R69Fz4wq4rf6uWhk39FyuXxIFADEtOHiwJ7vrYOepgNCMyRedTbvjjUVRDPGuhswwFpDVrOqkiRrCfIZwyjRar3XZmEeoxweEGCVB6kzfKA1YQGxpWkMXdnWxY3sDimOZQBKG6r24buzhkSOmkWoxeZWnSvqF4ZagEMVkdZ0KOzr9Y8D27pu9LVQERPSBwgocRjV5jktzhrbFgr115aXkvTzOTxw5pSxqTCkifdzr6Ub6K5Q4xQsi4Ar6VS7ZLxX61hfoLwJVHRM1N5gQnsP3FiOxNwkJguU7T1THJJ1EcSdhJOSCKONOoOvVqQ2pAcQTYcbAVO18jzqN0G1b1lFO7jKmxBkmI4l4eKbLIDYWvOicvKh9hYkoKJMkmHqCeXYFSqiVSRdwIvV16kfXeRmXzKl0jNft">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </UnlockCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockIdLengthValidationForRefreshCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that the CoauthLockId parameter is within size limitations of 1024 ASCII characters for RefreshCoauthLock.
        </Description>
        <Requests>
          <RefreshCoauthLock CoauthLockId="I1Iewhc0FUhHUVls6NPv9hnpzEmwRsTyZUBPxMDN8RTpNkLE1kbjDom8GGmpDh5XJOyOMK9e8Hly3KCNU8ojEk8mszGvXqOc1eQqady0S2VF7aWpkP35aVnCB9l7ZOadEzS36hrW9VQPpuNaXPk5pXHyngG9Aew5RmH5d6Ll5upwK6N29jYDRywJttG8WIWoGsxRiBGw70zEdftRvY0jTGkTHdxiueTJypFQh2VeDxfIktneGb8uJ9snWxdseZPdnUMUvI10uv0IDDL81vgpOi2eKnq7XJSaAq0CxoUO3Sx8QnRqBPzYp4QqzjXPLzogjtx1fBsFSoqYj5xUpiad2wSxYxOMjoqRIW1lxXDaJQcPmtfVfdvwpDYp44ahsHfM32lNk5lw0qUQxhGSZ699ku7RaZqMkfiesw8sozXrtZ1vd0lyuqQcUusIXna0U395qKxQO7XYiz3YVg88SJMn9BnDy7ZRUv177yb8GDlEN7By1KaIR7GxGIDx0HRmdivxxkuJGV6rEn21RPhJarislilveHl6A4hffbnjVKXZNZdkvsOL2QsWPbzA25qarXJVeBIjOjeyyjOLCxtHtyQwRaE8U2jbx9qIt2d3R69Fz4wq4rf6uWhk39FyuXxIFADEtOHiwJ7vrYOepgNCMyRedTbvjjUVRDPGuhswwFpDVrOqkiRrCfIZwyjRar3XZmEeoxweEGCVB6kzfKA1YQGxpWkMXdnWxY3sDimOZQBKG6r24buzhkSOmkWoxeZWnSvqF4ZagEMVkdZ0KOzr9Y8D27pu9LVQERPSBwgocRjV5jktzhrbFgr115aXkvTzOTxw5pSxqTCkifdzr6Ub6K5Q4xQsi4Ar6VS7ZLxX61hfoLwJVHRM1N5gQnsP3FiOxNwkJguU7T1THJJ1EcSdhJOSCKONOoOvVqQ2pAcQTYcbAVO18jzqN0G1b1lFO7jKmxBkmI4l4eKbLIDYWvOicvKh9hYkoKJMkmHqCeXYFSqiVSRdwIvV16kfXeRmXzKl0jNft" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockIdLengthValidationForRefreshCoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.InvalidGetCoauthLockExpirationTimeout" Category="WopiCoauth">
        <Description>
          Tests invalid timeout values for CoauthLockExpirationTimeout for GetCoauthLock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="59" CoauthLockMetadata="InvalidGetCoauthLockExpirationTimeout1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="3601" CoauthLockMetadata="InvalidGetCoauthLockExpirationTimeout2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </GetCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.InvalidRefreshCoauthLockExpirationTimeout" Category="WopiCoauth">
        <Description>
          Tests invalid timeout values for CoauthLockExpirationTimeout for RefreshCoauthLock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="InvalidRefreshCoauthLockExpirationTimeout" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="59" CoauthLockMetadata="InvalidRefreshCoauthLockExpirationTimeout">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RefreshCoauthLock>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="3601" CoauthLockMetadata="InvalidRefreshCoauthLockExpirationTimeout">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthExclusiveLockRequestOnExistingCoauthExclusiveLock" Category="WopiCoauth">
        <Description>
          Tests when a coauth exclusive lock is requested when a coauth exclusive lock already exists.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthExclusiveLockRequestOnExistingCoauthExclusiveLock1" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthExclusiveLockRequestOnExistingCoauthExclusiveLock2" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />  
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockTypeSwitchingOnExistingCoauthExclusiveLock" Category="WopiCoauth">
        <Description>
          Tests when a coauth lock type switch from coauth to coauth exclusive lock is requested on an existing coauth exclusive lock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockTypeSwitchingOnExistingCoauthExclusiveLock1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockTypeSwitchingOnExistingCoauthExclusiveLock2" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockTypeSwitchingOnExistingCoauthExclusiveLock1" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.UnlockCoauthLockWithNoLocks" Category="WopiCoauth">
        <Description>
          Tests UnlockCoauthLock conflict when requested with no existing locks.
        </Description>
        <Requests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </UnlockCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockWithNoLocks" Category="WopiCoauth"> 
        <Description>
          Tests RefreshCoauthLock conflict when requested with no existing locks.
        </Description>
        <Requests>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockWithNoLocks">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockMetadataLengthValidationForGetCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that the CoauthLockMetadata parameter is within size limits of 4KB for GetCoauthLock.
        </Description>
        <Requests>
          <!-- Test (4KB) for Metadata -->
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="BIG FILE HERE" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <!-- TODO: Uncomment after File routing implemented
              <ResponseCodeValidator ExpectedCode="400" /> -->
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockMetadataLengthValidationForRefreshCoauthLock" Category="WopiCoauth">
        <Description>
          Tests that the CoauthLockMetadata parameter is within size limits of 4KB for RefreshCoauthLock.
        </Description>
        <Requests>
          <!-- Test (4KB) for Metadata -->
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockMetadataLengthValidationForRefreshCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="BIG FILE HERE">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <!-- TODO: Uncomment after File routing implemented
              <ResponseCodeValidator ExpectedCode="400" /> -->
            </Validators>
          </RefreshCoauthLock>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockRequestOnExistingWopiLockWithLockUserVisibleTrue" Category="WopiCoauth">
        <Description>
          Tests that ConflictingLockUsername is returned when a Coauth lock is requested after an existing Wopi lock with header LockUserVisible set true
        </Description>
        <Requests>
          <Lock Lock="Client1" LockUserVisible="true" />
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="CoauthLockRequestOnExistingWopiLockWithLockUserVisibleTrue" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
              <ResponseHeaderValidator Header="X-WOPI-ConflictingLockUsername" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Incremental File Transfer Full File Chunking error test cases -->
  <TestGroup Name="IncrementalFileTransferErrorCases">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
      <PrereqTest>SupportsChunkedFileTransferPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="IncrementalFileTransfer.FileNotLockedAndFileSizeNotZero.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Host file is not locked and size is larger than 0.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientCoauthLockMismatchWithHostCoauthLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          PutChunkedFile using a mismatched coauth lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_2_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientCoauthLockAndWopiLockSetTogether.FailWithBadRequest400" Category="WopiCoauth">
        <Description>
          PutChunkedFile with WOPI Lock and Coauth Lock set at the same time.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock" Lock="Client_1_WopiLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientWopiLockMismatchWithHostWopiLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Host file is locked by WOPI Lock but client "X-WOPI-Lock" value does not match the lock currently on the file.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <Lock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Lock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" Lock="Client_2_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
              <ResponseHeaderValidator Header="X-WOPI-ConflictingMechanism" ExpectedValue="WOPI-Lock" IsRequired="true" ShouldMatch="true" />
              <ResponseHeaderValidator Header="X-WOPI-Lock" ExpectedValue="Client_1_Lock" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientCoauthLockMismatchWithHostWopiLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          File on host is locked by a WOPI Lock and the client provides a Coauth Lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <Lock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Lock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
              <ResponseHeaderValidator Header="X-WOPI-ConflictingMechanism" ExpectedValue="WOPI-Lock" IsRequired="true" ShouldMatch="true" />
              <ResponseHeaderValidator Header="X-WOPI-Lock" ExpectedValue="Client_1_Lock" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientCoauthLockMismatchWithHostCoauthExclusiveLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          File on host is locked by CoauthExclusive lock and client present a CoauthLock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthExclusiveLock" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthLock CoauthLockId="Client_2_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_2_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_2_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
              <ResponseHeaderValidator Header="X-WOPI-ConflictingMechanism" ExpectedValue="WOPI-CoauthExclusiveLock" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <UnlockCoauthLock CoauthLockId="Client_2_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientWopiLockMismatchWithHostCoauthExclusiveLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          File on host is locked by CoauthExclusiveLock and client presents a Wopi lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthExclusiveLock" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" Lock="Client_1_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
              <ResponseHeaderValidator Header="X-WOPI-ConflictingMechanism" ExpectedValue="WOPI-CoauthExclusiveLock" IsRequired="true" ShouldMatch="true" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientWopiLockMismatchWithHostCoauthLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          File on host is locked by CoauthLock, and client presents Wopi Lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" Lock="Client_1_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.ClientSequenceNumberMismatchWithHost.PreconditionFail412" Category="WopiCoauth">
        <Description>
          Sequence number provided by the WOPI client does not match the latest value on the host.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumber="0" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="412" />
            </Validators>
          </PutChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Incremental File Transfer Full File Chunking happy path test cases -->
  <TestGroup Name="IncrementalFileTransferWithFullFileChunkingScheme">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
      <PrereqTest>SupportsChunkedFileTransferPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="IncrementalFileTransfer.FullFile.UploadWithCoauthLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single put chunked file request with Coauth lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.UploadWithCoauthExclusiveLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single put chunked file request with Coauth Exclusive lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthExclusiveLock" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthExclusiveLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.UploadWithWopiLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single put chunked file request with WOPI lock.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <Lock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Lock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" Lock="Client_1_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.DeltaUploadsAndFullDownload.Success" Category="WopiCoauth">
        <Description>
          Multiple put chunked file requests.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-2" LastKnownHostContent="SampleTextVersion-1" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-2" LastKnownHostContent="Alt_SampleTextVersion-1" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-2" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-2" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.FileNotLockedAndFileSizeZero.Success" Category="WopiCoauth">
        <Description>
          Host file is not locked and size is zero.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="ZeroByteFile" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.DownloadUnexistedStreamShouldReturnEmptyStream.Success" Category="WopiCoauth">
        <Description>
          Client download streams that are not existed on host should return empty stream.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip"  AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="ZeroByteOfficeDocument" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.UploadSubsetOfFileStreams.Success" Category="WopiCoauth">
        <Description>
          Client upload subset of streams of a document, unmentioned streams should remain as they are.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt_SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt_SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.PutChunkedFileWithContentPropertiesAndPutFile.SuccessWithContentPropertyCleanedUp" Category="WopiCoauth">
        <Description>
          PutChunkedFile request first followed with PutFile request. ContentProperties with Retention = DeleteOnContentChange should be cleaned up.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentProperties>
              <ContentProperty Name="name1" Value="value1" Retention="KeepOnContentChange" />
              <ContentProperty Name="name2" Value="value2" Retention="DeleteOnContentChange" />
            </ContentProperties>
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentPropertiesToReturn>
              <ContentPropertyToReturn Value="name1" />
              <ContentPropertyToReturn Value="name2" />
            </ContentPropertiesToReturn>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentPropertyValidator Name="name1" ExpectedValue="value1" ExpectedRetention="KeepOnContentChange" />
                <ContentPropertyValidator Name="name2" ExpectedValue="value2" ExpectedRetention="DeleteOnContentChange" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentPropertiesToReturn>
              <ContentPropertyToReturn Value="name1" />
              <ContentPropertyToReturn Value="name2" />
            </ContentPropertiesToReturn>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentPropertyValidator Name="name1" ExpectedValue="value1" ExpectedRetention="KeepOnContentChange" />
                <ContentPropertyValidator Name="name2" ShouldBeReturned="false" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.FullFile.DownloadWithLastZipChunk.Success" Category="WopiCoauth">
        <Description>
          Client sends GetChunkedFile request with ChunksToReturn set to LastZipChunk. If the file is not a zip archive, this would behave the same as None.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="LastZipChunk" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <!-- No blob should be returned for MainContent stream -->
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="0">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Incremental File Transfer Zip Chunking happy path test cases -->
  <TestGroup Name="IncrementalFileTransferWithZipChunkingScheme">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
      <PrereqTest>SupportsChunkedFileTransferPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="IncrementalFileTransfer.Zip.UploadWithCoauthLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with Coauth lock, followed by Zip format download request.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DownloadWithNoneChunksToReturn.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with Coauth lock, followed by ChunksToReturn.None Zip format download request.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="None" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="None" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="0">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DownloadWithLastZipChunk.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with Coauth lock, followed by ChunksToReturn.LastZipChunk Zip format download request.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="LastZipChunk" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="LastZipChunk" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <!-- One LastZipChunk blob for MainContent and one for Alternate -->
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="2">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DownloadWithZipAndHostReturnsFullFileDueToNonZipArchive.Success" Category="WopiCoauth">
        <Description>
          Initiate a single FullFile format upload request with Coauth lock, followed by Zip format download, but host returns FullFile format because host content not eligible for Zip.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="FullFile" StreamId="MainContent" NewContent="SampleTextVersion-1" LastKnownHostContent="" />
              <ContentStream ChunkingScheme="FullFile" StreamId="Alternate" NewContent="Alt-SampleTextVersion-1" LastKnownHostContent="" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="SampleTextVersion-1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="FullFile" AlreadyExistingContent="" ExpectedContent="Alt-SampleTextVersion-1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DownloadFullFileAndHostReturnsZipDueToContentEligibleForZip.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with Coauth lock, followed by FullFile download request but host returns Zip Chunking format because host content eligible for Zip.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="FullFile" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContent="" />
              <ContentFilter ChunkingScheme="FullFile" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContent="" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.UploadWithCoauthExclusiveLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with Coauth Exclusive lock, followed by Zip format download.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthExclusiveLock" CoauthLockType="CoauthExclusive">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthExclusiveLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthExclusiveLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.UploadWithWopiLock.Success" Category="WopiCoauth">
        <Description>
          Initiate a single Zip format upload request with WOPI lock, followed by Zip format download.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <Lock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Lock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" Lock="Client_1_Lock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="Client_1_Lock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DeltaUploadsAndFullDownload.Success" Category="WopiCoauth">
        <Description>
          Multiple Zip format upload requests, followed by Zip format full download.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Main_V1" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Alt_V1" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V2" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V2" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DeltaUploadsAndDeltaDownloadZeroBlobs.Success" Category="WopiCoauth">
        <Description>
          Multiple Zip format upload requests, followed by Zip format delta download.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Main_V1" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Alt_V1" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="NonZeroByteExcel_Main_V2" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="NonZeroByteExcel_Alt_V2" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="0">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="NonZeroByteExcel_Main_V2" ExpectedContentResourceId="NonZeroByteExcel_Main_V2" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="NonZeroByteExcel_Alt_V2" ExpectedContentResourceId="NonZeroByteExcel_Alt_V2" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DeltaUploadsAndDeltaDownloadNonZeroBlobs.Success" Category="WopiCoauth">
        <Description>
          Multiple Zip format upload requests, followed by Zip format delta download.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Main_V1" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V2" LastKnownHostContentResourceId="NonZeroByteExcel_Alt_V1" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="NonZeroByteExcel_Main_V1" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="NonZeroByteExcel_Alt_V1" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="18">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="NonZeroByteExcel_Main_V1" ExpectedContentResourceId="NonZeroByteExcel_Main_V2" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="NonZeroByteExcel_Alt_V1" ExpectedContentResourceId="NonZeroByteExcel_Alt_V2" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.FileNotLockedAndFileSizeZero.Success" Category="WopiCoauth">
        <Description>
          Host file is not locked and size is zero.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="ZeroByteFile" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.DownloadUnexistedStreamShouldReturnEmptyStream.Success" Category="WopiCoauth">
        <Description>
          Client download streams that are not existed on host should return empty stream.
        </Description>
        <Requests>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="ZeroByteOfficeDocument" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.UploadSubsetOfFileStreams.Success" Category="WopiCoauth">
        <Description>
          Client upload subset of streams of a document, unmentioned streams should remain as they are.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="Alternate" NewContentResourceId="NonZeroByteExcel_Alt_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
              <ContentFilter ChunkingScheme="Zip" StreamId="Alternate" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Main_V1" />
                <ContentStreamValidator StreamId="Alternate" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" ExpectedContentResourceId="NonZeroByteExcel_Alt_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="IncrementalFileTransfer.Zip.PutChunkedFileWithContentPropertiesAndPutFile.SuccessWithContentPropertyCleanedUp" Category="WopiCoauth">
        <Description>
          PutChunkedFile request first followed with PutFile request. ContentProperties with Retention = DeleteOnContentChange should be cleaned up.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentProperties>
              <ContentProperty Name="name1" Value="value1" Retention="KeepOnContentChange" />
              <ContentProperty Name="name2" Value="value2" Retention="DeleteOnContentChange" />
            </ContentProperties>
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteExcel_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </PutChunkedFile>
          <GetChunkedFile>
            <ContentPropertiesToReturn>
              <ContentPropertyToReturn Value="name1" />
              <ContentPropertyToReturn Value="name2" />
            </ContentPropertiesToReturn>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">=" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentPropertyValidator Name="name1" ExpectedValue="value1" ExpectedRetention="KeepOnContentChange" />
                <ContentPropertyValidator Name="name2" ExpectedValue="value2" ExpectedRetention="DeleteOnContentChange" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
          <Lock Lock="LockString" />
          <PutFile Lock="LockString" ResourceId="WordSimpleDocument" />
          <Unlock Lock="LockString" />
          <GetChunkedFile>
            <ContentPropertiesToReturn>
              <ContentPropertyToReturn Value="name1" />
              <ContentPropertyToReturn Value="name2" />
            </ContentPropertiesToReturn>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema">
                <ContentPropertyValidator Name="name1" ExpectedValue="value1" ExpectedRetention="KeepOnContentChange" />
                <ContentPropertyValidator Name="name2" ShouldBeReturned="false" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <!-- Contains test cases that verify RenameFile with CoauthLock presented or existed on file-->
  <TestGroup Name="RenameFileWithCoauthLockSupported">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>FileEditingPrereq</PrereqTest>
      <PrereqTest>LocksPrereq</PrereqTest>
      <PrereqTest>RenameFilePrereq</PrereqTest>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="RenameFile.ClientPresentsCoauthLockWithHostCoauthLock.Success" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with same CoauthLock on host. Request should succeed with file content unchanged.
        </Description>
        <Requests>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="ZeroByteOfficeDocument" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
            <SaveState>
              <State Name="SequenceNumberStateOverride" Source="X-WOPI-SequenceNumber" SourceType="Header" />
            </SaveState>
          </GetChunkedFile>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <PutChunkedFile SequenceNumberStateKey="SequenceNumberStateOverride" CoauthLockId="Client_1_CoauthLock">
            <ContentStreams>
              <ContentStream ChunkingScheme="Zip" StreamId="MainContent" NewContentResourceId="NonZeroByteWord_Main_V1" LastKnownHostContentResourceId="ZeroByteOfficeDocument" />
            </ContentStreams>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-SequenceNumber" Comparator=">" ExpectedStateKey="SequenceNumberStateOverride" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
            </Validators>
          </PutChunkedFile>
          <RenameFile CoauthLockId="Client_1_CoauthLock" Name="RenameFile_ClientPresentsCoauthLockWithHostCoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="RenameFile_ClientPresentsCoauthLockWithHostCoauthLock" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="BaseFileName" ExpectedValue="RenameFile_ClientPresentsCoauthLockWithHostCoauthLock.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
          <GetChunkedFile>
            <ContentFilters>
              <ContentFilter ChunkingScheme="Zip" StreamId="MainContent" ChunksToReturn="All" AlreadyExistingContentResourceId="NonZeroByteWord_Main_V1" />
            </ContentFilters>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-ItemVersion" IsRequired="true" />
              <!-- File content should not change after RenameFile, no blob should be returned for MainContent stream -->
              <FramesValidator MessageJsonPayloadSchema="GetChunkedFileResponseSchema" ExpectedHostBlobsCount="0">
                <ContentStreamValidator StreamId="MainContent" ExpectedChunkingScheme="Zip" AlreadyExistingContentResourceId="NonZeroByteWord_Main_V1" ExpectedContentResourceId="NonZeroByteWord_Main_V1" />
              </FramesValidator>
            </Validators>
          </GetChunkedFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsCoauthLockWithHostNoLock.Success" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with CoauthLock and host file is unlocked. Request should succeed.
        </Description>
        <Requests>
          <RenameFile CoauthLockId="Client_1_CoauthLock" Name="RenameFile_ClientPresentsCoauthLockWithHostNoLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="RenameFile_ClientPresentsCoauthLockWithHostNoLock" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="BaseFileName" ExpectedValue="RenameFile_ClientPresentsCoauthLockWithHostNoLock.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsNoLockWithHostNoLock.Success" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with neither Wopi nor CoauthLock being set and host file is unlocked. Request should succeed.
        </Description>
        <Requests>
          <RenameFile Name="RenameFile_ClientPresentsNoLockWithHostNoLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <JsonResponseContentValidator>
                <FileNameProperty Name="Name" ExpectedValue="RenameFile_ClientPresentsNoLockWithHostNoLock" />
              </JsonResponseContentValidator>
            </Validators>
          </RenameFile>
          <CheckFileInfo>
            <Validators>
              <JsonResponseContentValidator>
                <FileNameProperty Name="BaseFileName" ExpectedValue="RenameFile_ClientPresentsNoLockWithHostNoLock.wopitest" />
              </JsonResponseContentValidator>
            </Validators>
          </CheckFileInfo>
        </Requests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsNoLockWithHostCoauthLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with neither Wopi nor CoauthLock being set. Host file is locked by CoauthLock. Request should fail with 409 Conflict.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <RenameFile Name="ValidatorTestFileRenamed">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsWopiLockWithHostCoauthLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with Wopi lock. Host file is locked by CoauthLock. Request should fail with 409 Conflict.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <RenameFile Name="ValidatorTestFileRenamed" Lock="WrongLock" >
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsWrongCoauthLockWithHostCoauthLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with CoauthLock. Host file is locked by CoauthLock but presented lock id does not exist in coauth table. Request should fail with 409 Conflict.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client_1_CoauthLock" CoauthLockExpirationTimeout="600" CoauthLockMetadata="Client_1_CoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </GetCoauthLock>
          <RenameFile Name="ValidatorTestFileRenamed" CoauthLockId="WrongLockId">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client_1_CoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="RenameFile.ClientPresentsCoauthLockWithHostWopiLock.FailWithConflict409" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with CoauthLock. Host file is locked by WopiLock. Request should fail with 409 Conflict.
        </Description>
        <Requests>
          <Lock Lock="WopiLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Lock>
          <RenameFile Name="ValidatorTestFileRenamed" CoauthLockId="WrongLockId">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RenameFile>
        </Requests>
        <CleanupRequests>
          <Unlock Lock="WopiLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </Unlock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="RenameFile.ClientCoauthLockAndWopiLockSetTogether.FailWithBadRequest400" Category="WopiCoauth">
        <Description>
          Client sends RenameFile request with WopiLock and CoauthLock being set together. Request should fail with 400 BadRequest.
        </Description>
        <Requests>
          <RenameFile Name="ValidatorTestFileRenamed" CoauthLockId="CoauthLockId" Lock="WopiLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="400" />
            </Validators>
          </RenameFile>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>

  <TestGroup Name="CoauthLockExpiration" HasDelay="true">
    <PrereqTests>
      <PrereqTest>WopiValidatorPrereq</PrereqTest>
      <PrereqTest>SupportsCoauthPrereq</PrereqTest>
    </PrereqTests>
    <TestCases>
      <TestCase Name="CoauthLock.GetCoauthTableAfterLockExpiration" Category="WopiCoauth">
        <Description>
          Tests that the coauth table request will return only coauth locks that have not expired.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="GetCoauthTableAfterLockExpiration1" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <Delay DelayTimeInSeconds="60" />
          <GetCoauthLock CoauthLockId="Client2" CoauthLockExpirationTimeout="120" CoauthLockMetadata="GetCoauthTableAfterLockExpiration2" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client2', CoauthLockMetadata:'GetCoauthTableAfterLockExpiration2', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client2">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockValidation" Category="WopiCoauth">
        <Description>
          Tests that a refresh coauth lock request refreshes the coauth lock expiration timeout.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="RefreshCoauthLockValidation" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <Delay DelayTimeInSeconds="30" />
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="240" CoauthLockMetadata="RefreshCoauthLockValidation">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </RefreshCoauthLock>
          <Delay DelayTimeInSeconds="30" />
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[{CoauthLockId:'Client1', CoauthLockMetadata:'RefreshCoauthLockValidation', CoauthLockType:'Coauth', UserFriendlyName:'*', CoauthLockTime:'*'}]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="1" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
        <CleanupRequests>
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
            </Validators>
          </UnlockCoauthLock>
        </CleanupRequests>
      </TestCase>
      <TestCase Name="CoauthLock.CoauthLockExpirationTimeoutValidation" Category="WopiCoauth">
        <Description>
          Tests that a coauth lock timeout expiration is reflected in the coauth table.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="CoauthLockExpirationTimeoutValidation" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <Delay DelayTimeInSeconds="60" />
          <GetCoauthTable>
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
              <JsonSchemaValidator Schema="CoauthTableSchema" />
              <JsonResponseContentValidator>
                <ResponseBodyProperty Name="CoauthTable" ExpectedValue="[]" IsRequired="true" />
                <ArrayLengthProperty Name="CoauthTable" ExpectedValue="0" IsRequired="true" />
              </JsonResponseContentValidator>
            </Validators>
          </GetCoauthTable>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.UnlockCoauthLockOnExpiredCoauthLock" Category="WopiCoauth">
        <Description>
          Tests UnlockCoauthLock on an expired coauth lock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="UnlockCoauthLockOnExpiredCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <Delay DelayTimeInSeconds="60" />
          <UnlockCoauthLock CoauthLockId="Client1">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </UnlockCoauthLock>
        </Requests>
      </TestCase>
      <TestCase Name="CoauthLock.RefreshCoauthLockOnExpiredCoauthLock" Category="WopiCoauth">
        <Description>
          Tests RefreshCoauthLock on an expired lock.
        </Description>
        <Requests>
          <GetCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="60" CoauthLockMetadata="RefreshCoauthLockOnExpiredCoauthLock" CoauthLockType="Coauth">
            <Validators>
              <ResponseCodeValidator ExpectedCode="200" />
              <ResponseHeaderValidator Header="X-WOPI-CoauthTableVersion" IsRequired="true" />
            </Validators>
          </GetCoauthLock>
          <Delay DelayTimeInSeconds="60" />
          <RefreshCoauthLock CoauthLockId="Client1" CoauthLockExpirationTimeout="120" CoauthLockMetadata="RefreshCoauthLockOnExpiredCoauthLock">
            <Validators>
              <ResponseCodeValidator ExpectedCode="409" />
            </Validators>
          </RefreshCoauthLock>
        </Requests>
      </TestCase>
    </TestCases>
  </TestGroup>
</WopiValidation>
